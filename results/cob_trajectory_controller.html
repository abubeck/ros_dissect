<html>
<body>
    <table summary="code examples">
 
        <tr>

        <td><pre style="border: 1px solid #888;padding: 2px">
1:	ROS_WARN("Manipulator still in motion, call stop first!");
2:	return false;
3:	delete m_pRefVals;
4:	m_pRefVals = NULL;
5:	m_ErrorMsg.assign("Internal Error: Unable to start movement, other control Job still active.");
6:	return false;
7:	return true;
8:	m_DOF = DOF;
9:	m_pRefVals = NULL;
10:	isMoving = false;
11:	SetPTPvel(PTPvel);
12:	SetPTPacc(PTPacc);
13:	m_P = 4.0;
14:	m_Vorsteuer = 0.9;
15:	m_AllowedError = maxError;
16:	m_CurrentError = 0.0;
17:	m_TargetError = 0.02;
18:	overlap_time = 0.4;
19:	m_ExtraTime = 3;
20:		delete m_pRefVals;
21:	{ return m_vel_js;
22:	{ return m_acc_js;
23:	m_vel_js.resize(m_DOF);
24:	for (int i = 0;
25:	for (int i = 0; i < m_DOF;
26:		m_vel_js.at(i) = vel;
27:	m_acc_js.resize(m_DOF);
28:	for (int i = 0;
29:	for (int i = 0; i < m_DOF;
30:		m_acc_js.at(i) = acc;
31:	double vel = 10000;
32:	for	(unsigned int i = 0;
33:	for	(unsigned int i = 0; i<m_vel_js.size();
34:			vel = m_vel_js.at(i);
35:	double acc = 10000;
36:	for	(unsigned int i = 0;
37:	for	(unsigned int i = 0; i<m_acc_js.size();
38:			acc = m_acc_js.at(i);
39:					;
40:	m_pRefVals = new RefValJS_PTP(conf_current, conf_goal, vel, acc);
41:	startTime_.SetNow();
42:	isMoving = true;
43:	TotalTime_ = m_pRefVals->getTotalTime();
44:	ROS_INFO("Starting control of trajectory: %f s long", TotalTime_);
45:	return true;
46:		return moveThetas(pfad.points[1].positions, conf_current);
47:	for(unsigned int i = 0;
48:	for(unsigned int i = 0; i < pfad.points.front().positions.size();
49:			ROS_ERROR("Cannot start trajectory motion, manipulator not in trajectory start position.");
50:			return false;
51:	double vel = m_vel_js.at(0);
52:	for	(unsigned int i = 0;
53:	for	(unsigned int i = 0; i<m_vel_js.size();
54:			vel = m_vel_js.at(i);
55:	double acc = m_acc_js.at(0);
56:	for	(unsigned int i = 0;
57:	for	(unsigned int i = 0; i<m_acc_js.size();
58:			acc = m_acc_js.at(i);
59:	m_pRefVals = new RefValJS_PTP_Trajectory(pfad, vel, acc, true);
60:	startTime_.SetNow();
61:	isMoving = true;
62:	TotalTime_ = m_pRefVals->getTotalTime();
63:	ROS_INFO("Starting control of trajectory: %f s long", TotalTime_);
64:	return true;
65:		TimeStamp timeNow_;
66:		timeNow_.SetNow();
67:				return false;
68:		double t = timeNow_ - startTime_;
69:		std::vector<double> m_qsoll = m_pRefVals->r_t( t );
70:		std::vector<double> m_vsoll = m_pRefVals->dr_dt(t);
71:				last_q = m_pRefVals->r_t( 0.0 );
72:				last_q1 = m_pRefVals->r_t( 0.0 );
73:				last_q2 = m_pRefVals->r_t( 0.0 );
74:				last_q3 = m_pRefVals->r_t( 0.0 );
75:				last_q = m_pRefVals->r_t( t - overlap_time );
76:				last_q1 = m_pRefVals->r_t( t - (3.0*overlap_time/4.0) );
77:				last_q2 = m_pRefVals->r_t( t - (overlap_time/2.0) );
78:				last_q3 = m_pRefVals->r_t( t - (overlap_time/4.0) );
79:		double len = 0;
80:		for(int i = 0;
81:		for(int i = 0; i < m_DOF;
82:			 len +=  (m_qsoll.at(i) - current_pos.at(i)) * (m_qsoll.at(i) - current_pos.at(i));
83:		m_CurrentError = sqrt(len);
84:					ROS_ERROR("Current control error exceeds limit: %f >= %f", m_CurrentError, m_AllowedError);
85:					isMoving = false;
86:					return false;
87:				desired_vel.resize(m_DOF);
88:				for(int i = 0;
89:				for(int i = 0; i < m_DOF;
90:					desired_vel.at(i) = m_vsoll.at(i) * m_Vorsteuer + ( m_qsoll.at(i) - current_pos.at(i) ) * m_P;
91:				return true;
92:			ROS_INFO("Probably finished trajectory");
93:			isMoving = false;
94:			desired_vel.resize(m_DOF);
95:			for(int i = 0;
96:			for(int i = 0; i < m_DOF;
97:				desired_vel.at(i) = 0.0;
98:			return true;
99:	return false;
100:	return x*x;
101:const double RefValJS_PTP::weigths[] = { 1.5, 1.5, 1.0, 1.0, 0.8, 0.8, 0.7 };
102:	m_start = start;
103:	m_ziel = ziel;
104:	m_direction.resize(start.size());
105:	for(unsigned int i = 0;
106:	for(unsigned int i = 0; i < start.size();
107:		m_direction.at(i) = ziel.at(i) - start.at(i);
108:	double max = m_direction.at(0);
109:	double min = m_direction.at(0);
110:	for(unsigned int i = 0;
111:	for(unsigned int i = 0; i < m_direction.size();
112:			max = m_direction.at(i);
113:			min = m_direction.at(i);
114:	max = fabs(max);
115:	min = fabs(min);
116:	m_length = norm(m_direction);
117:	m_v_rad_s = v_rad_s;
118:	m_a_rad_s2 = a_rad_s2;
119:	double a = fabs(m_a_rad_s2);
120:	double v = fabs(m_v_rad_s);
121:		m_T1 = m_T3 = v / a;
122:		m_T2 = (m_length - v*v/a) / v;
123:		m_sv2 = 1.0 / (m_T1 + m_T2);
124:		m_sa1 = m_sv2 / m_T1;
125:		m_sa3 = -m_sa1;
126:		m_T2 = 0.0;
127:		m_T1 = m_T3 = sqrt(m_length / a);
128:		m_sv2 = 1.0 / m_T1;
129:		m_sa1 = m_sv2 / m_T1;
130:		m_sa3 = -m_sa1;
131:	std::vector<double> soll;
132:	soll.resize(m_start.size());
133:		soll = m_start;
134:		for(unsigned int i = 0;
135:		for(unsigned int i = 0; i < m_start.size();
136:			soll.at(i) = m_start.at(i) + m_direction.at(i) * s;
137:		soll = m_ziel;
138:	return soll;
139:		return 1.0;
140:		return 0.5*m_sa1*m_T1*m_T1 + m_sv2*m_T2 + m_sv2*(t-m_T1-m_T2) + 0.5*m_sa3*sqr(t-m_T1-m_T2);
141:		return 0.5*m_sa1*m_T1*m_T1 + m_sv2*(t-m_T1);
142:		return 0.5*m_sa1*t*t;
143:	else return 0.0;
144:		return 0.0;
145:		return m_sv2 + m_sa3*(t-m_T1-m_T2);
146:		return m_sv2;
147:		return m_sa1*t;
148:	else return 0.0;
149:	std::vector<double> result = m_start;
150:		for(unsigned int i = 0;
151:		for(unsigned int i = 0; i<result.size();
152:			result.at(i) = 0.0;
153:		result = m_direction;
154:	return result;
155:const double RefValJS_PTP_Trajectory::weigths[] = { 1.5, 1.5, 1.0, 1.0, 0.8, 0.8, 0.7 };
156:	return x*x;
157:	m_trajectory = trajectory;
158:	m_length = 0;
159:	m_stepSize = 0.0175;
160:	m_length_parts.clear();
161:	m_s_parts.clear();
162:		throw std::runtime_error("Tried to create reference values for empty trajectory!");
163:	std::vector<std::vector<double> > zwischenPunkte;
164:		double between_stepsize = 0.8;
165:		for (unsigned int i=0;
166:		for (unsigned int i=0; i < m_trajectory.points.size()-1;
167:			std::vector<double> direction;
168:			direction.resize( m_trajectory.points[i+1].positions.size());
169:			double len = 0;
170:			for(unsigned int j = 0;
171:			for(unsigned int j = 0; j <  m_trajectory.points[i+1].positions.size();
172:				direction.at(j) = m_trajectory.points[i+1].positions.at(j)-m_trajectory.points[i].positions.at(j);
173:				len += direction.at(j) * direction.at(j);
174:			double dist = sqrt(len);
175:			int num_segs = ceil(dist/between_stepsize);
176:			zwischenPunkte.resize(num_segs);
177:			for (int j=0;
178:			for (int j=0; j < num_segs;
179:				std::vector<double> betw_joint;
180:				betw_joint.resize(direction.size());
181:				for(unsigned int d=0;
182:				for(unsigned int d=0; d < direction.size();
183:					betw_joint.at(d) = m_trajectory.points[i].positions.at(d) + direction.at(d) * ( (double)j / (double)num_segs );
184:				zwischenPunkte.at(j) = betw_joint;
185:		zwischenPunkte.push_back( m_trajectory.points.back().positions );
186:		zwischenPunkte.resize(trajectory.points.size());
187:		for(unsigned int i = 0;
188:		for(unsigned int i = 0; i < trajectory.points.size();
189:			zwischenPunkte.at(i) = trajectory.points.at(i).positions;
190:	ROS_INFO("Calculated %d zwischenPunkte", zwischenPunkte.size());
191:	m_TrajectorySpline.setCtrlPoints(zwischenPunkte);
192:		throw std::runtime_error("Error in BSplineND::ipoWithConstSampleDist!");
193:	m_SplinePoints = zwischenPunkte;
194:	ROS_INFO("Calculated %d splinepoints", m_SplinePoints.size());
195:	m_length_cumulated.clear();
196:	m_length_cumulated.push_back(0.0);
197:	for (unsigned int i=0;
198:	for (unsigned int i=0; i < m_SplinePoints.size()-1;
199:		std::vector<double> dist;
200:		dist.resize(m_SplinePoints[i].size());
201:		for(unsigned int j=0;
202:		for(unsigned int j=0; j < m_SplinePoints[i].size();
203:			dist.at(j) = m_SplinePoints[i+1].at(j) - m_SplinePoints[i].at(j);
204:		m_length_parts.push_back( norm(dist) );
205:		m_length += norm(dist);
206:		m_length_cumulated.push_back(m_length);
207:	m_param_length = m_TrajectorySpline.getMaxdPos();
208:	for (unsigned int i=0;
209:	for (unsigned int i=0; i < m_length_parts.size();
210:		m_s_parts.push_back( m_length_parts[i] / m_length );
211:	m_v_rad_s = v_rad_s;
212:	m_a_rad_s2 = a_rad_s2;
213:	double a = fabs(m_a_rad_s2);
214:	double v = fabs(m_v_rad_s);
215:		m_T1 = m_T3 = v / a;
216:		m_T2 = (m_length - v*v/a) / v;
217:		m_sv2 = 1.0 / (m_T1 + m_T2);
218:		m_sa1 = m_sv2 / m_T1;
219:		m_sa3 = -m_sa1;
220:		m_T2 = 0.0;
221:		m_T1 = m_T3 = sqrt(m_length / a);
222:		m_sv2 = 1.0 / m_T1;
223:		m_sa1 = m_sv2 / m_T1;
224:		m_sa3 = -m_sa1;
225:	std::vector<double> soll;
226:		soll = m_trajectory.points.front().positions;
227:		vecd_it start = m_length_cumulated.begin();
228:		vecd_it end = m_length_cumulated.end();
229:		vecd_it it = upper_bound(start, end, s * m_length);
230:		int i = int(it-start) - 1;
231:		double frac = (s * m_length - m_length_cumulated[i]) / m_length_parts[i];
232:		soll.resize(m_SplinePoints[i].size());
233:		for(unsigned int j = 0;
234:		for(unsigned int j = 0; j < m_SplinePoints[i].size();
235:			soll.at(j) = m_SplinePoints[i].at(j) + (m_SplinePoints[i+1].at(j)-m_SplinePoints[i].at(j))*frac;
236:		soll = m_trajectory.points.back().positions;
237:	return soll;
238:		return 1.0;
239:		return 0.5*m_sa1*m_T1*m_T1 + m_sv2*m_T2 + m_sv2*(t-m_T1-m_T2) + 0.5*m_sa3*sqr(t-m_T1-m_T2);
240:		return 0.5*m_sa1*m_T1*m_T1 + m_sv2*(t-m_T1);
241:		return 0.5*m_sa1*t*t;
242:	else return 0.0;
243:		return 0.0;
244:		return m_sv2 + m_sa3*(t-m_T1-m_T2);
245:		return m_sv2;
246:		return m_sa1*t;
247:	else return 0.0;
248:	std::vector<double> result = m_trajectory.points.front().positions;
249:		for(unsigned int j=0;
250:		for(unsigned int j=0; j < result.size();
251:			result.at(j) = 0.0;
252:		vecd_it start = m_length_cumulated.begin();
253:		vecd_it end = m_length_cumulated.end();
254:		vecd_it it = upper_bound(start, end, s * m_length);
255:		int i = int(it-start) - 1;
256:		double frac = (s * m_length - m_length_cumulated[i]) / m_length_parts[i];
257:		std::vector<double> vi;
258:		std::vector<double> vii;
259:		double step_s = m_stepSize / m_param_length;
260:			step_s = m_length_parts[0] / m_length;
261:			vi.resize(m_SplinePoints[i].size());
262:			for(unsigned int k = 0;
263:			for(unsigned int k = 0; k < m_SplinePoints[i].size();
264:				vi.at(k) = (m_SplinePoints[1].at(k) - m_SplinePoints[0].at(k)) / step_s;
265:			vii = vi;
266:			step_s = (m_length_parts[i]) / m_length;
267:			vii.resize(m_SplinePoints[i].size());
268:			for(unsigned int k = 0;
269:			for(unsigned int k = 0; k < m_SplinePoints[i].size();
270:				vii.at(k) = (m_SplinePoints[i+1].at(k) - m_SplinePoints[i].at(k)) / step_s;
271:			vi = vii;
272:			step_s = (m_length_parts[i]+m_length_parts[i-1]) / m_length;
273:			vi.resize(m_SplinePoints[i].size());
274:			for(unsigned int k = 0;
275:			for(unsigned int k = 0; k < m_SplinePoints[i].size();
276:				vi.at(k) = (m_SplinePoints[i+1].at(k) - m_SplinePoints[i-1].at(k)) / step_s;
277:			step_s = (m_length_parts[i]+m_length_parts[i+1]) / m_length;
278:			vii.resize(m_SplinePoints[i].size());
279:			for(unsigned int k = 0;
280:			for(unsigned int k = 0; k < m_SplinePoints[i].size();
281:				vii.at(k) = (m_SplinePoints[i+2].at(k) - m_SplinePoints[i].at(k)) / step_s;
282:		result.resize(m_SplinePoints[i].size());
283:		for(unsigned int k = 0;
284:		for(unsigned int k = 0; k < m_SplinePoints[i].size();
285:			result.at(k) = vi.at(k) + (vii.at(k)-vi.at(k))*frac;
286:	return result;
287:	m_TimeStamp.tv_sec = 0;
288:	m_TimeStamp.tv_nsec = 0;
289:	::clock_gettime(CLOCK_REALTIME, &m_TimeStamp);
290:	return double(LargeInt.tv_sec) + double(LargeInt.tv_nsec) / 1e9;
291:	::timespec DeltaTime;
292:		DeltaTime.tv_sec = 0;
293:		DeltaTime.tv_nsec = 0;
294:		return DeltaTime;
295:	DeltaTime.tv_sec = ::time_t(TimeS);
296:		= static_cast<long int>((TimeS - double(DeltaTime.tv_sec)) * 1e9);
297:	return DeltaTime;
298:	::timespec Res;
299:	Res.tv_sec = m_TimeStamp.tv_sec - EarlierTime.m_TimeStamp.tv_sec;
300:	Res.tv_nsec = m_TimeStamp.tv_nsec - EarlierTime.m_TimeStamp.tv_nsec;
301:		Res.tv_sec--;
302:		Res.tv_nsec += 1000000000;
303:	return TimespecToDouble(Res);
304:	::timespec Dbl = DoubleToTimespec(TimeS);
305:	m_TimeStamp.tv_sec += Dbl.tv_sec;
306:	m_TimeStamp.tv_nsec += Dbl.tv_nsec;
307:		m_TimeStamp.tv_sec++;
308:		m_TimeStamp.tv_nsec -= 1000000000;
309:	::timespec Dbl = DoubleToTimespec(TimeS);
310:	m_TimeStamp.tv_sec -= Dbl.tv_sec;
311:	m_TimeStamp.tv_nsec -= Dbl.tv_nsec;
312:		m_TimeStamp.tv_sec--;
313:		m_TimeStamp.tv_nsec += 1000000000;
314:	if (m_TimeStamp.tv_sec > Time.m_TimeStamp.tv_sec) return true;
315:		(m_TimeStamp.tv_nsec > Time.m_TimeStamp.tv_nsec)) return true;
316:	return false;
317:	if (m_TimeStamp.tv_sec < Time.m_TimeStamp.tv_sec) return true;
318:		(m_TimeStamp.tv_nsec < Time.m_TimeStamp.tv_nsec)) return true;
319:	return false;
320:	lSeconds = m_TimeStamp.tv_sec;
321:	lNanoSeconds = m_TimeStamp.tv_nsec;
322:};
323:	m_TimeStamp.tv_sec = lSeconds;
324:	m_TimeStamp.tv_nsec = lNanoSeconds;
325:};
326:using namespace std;
327:using namespace KDL;
328:KDL::JntArray VirtualQ;
329:KDL::JntArray q;
330:KDL::JntArray q_last;
331:ros::Time last;
332:bool started = false;
333:<font color="#FF0000">ros::Publisher arm_pub_;</font>{}
334:<font color="#FF0000">ros::ServiceServer serv_reset;</font>{}
335:	ros::Time now = ros::Time::now();
336:	double dt = now.toSec() - last.toSec();
337:	last = now;
338:	double horizon = 3.0*dt;
339:	trajectory_msgs::JointTrajectory traj;
340:	traj.header.stamp = ros::Time::now()+ros::Duration(0.01);
341:	traj.joint_names.push_back("arm_1_joint");
342:	traj.joint_names.push_back("arm_2_joint");
343:	traj.joint_names.push_back("arm_3_joint");
344:	traj.joint_names.push_back("arm_4_joint");
345:	traj.joint_names.push_back("arm_5_joint");
346:	traj.joint_names.push_back("arm_6_joint");
347:	traj.joint_names.push_back("arm_7_joint");
348:	traj.points.resize(1);
349:	bool nonzero = false;
350:	for(int i = 0;
351:	for(int i = 0; i < 7;
352:			traj.points[0].positions.push_back(VirtualQ(i) + q_dot(i)*horizon);
353:			traj.points[0].velocities.push_back(q_dot(i));
354:			VirtualQ(i) += q_dot(i)*dt;
355:			nonzero = true;
356:	traj.points[0].time_from_start = ros::Duration(horizon);
357:<font color="#FF0000">		arm_pub_.publish(traj);</font>{}
358:	JntArray q_temp(7);
359:	int count = 0;
360:    bool parsed = false;
361:	for(unsigned int i = 0;
362:	for(unsigned int i = 0; i < names.size();
363:				q_temp(count) = positions[i];
364:				count++;
365:				parsed = true;
366:		return q_last;
367:	q_last = q_temp;
368:		VirtualQ = q_temp;
369:		started = true;
370:		last = ros::Time::now();
371:		ROS_INFO("Starting up controller with first configuration: %f %f %f", q_temp(0), q_temp(1), q_temp(2));
372:	return q_temp;
373:	started = false;
374:	return true;
375:	std::vector<std::string> names = msg->name;
376:	std::vector<double> positions = msg->position;
377:	q = parseJointStates(names,positions);
378:	KDL::JntArray q_dot;
379:	q_dot.resize(7);
380:	for(unsigned int j = 0;
381:	for(unsigned int j = 0; j < 7;
382:		q_dot(j) = msg->velocities.at(j).value;
383:	sendVel(q_dot);
384:<font color="#FF0000">	ros::init(argc, argv, "cob_simulation_tester");</font>{}
385:<font color="#FF0000">	ros::NodeHandle n;</font>{}
386:<font color="#FF0000">	arm_pub_ = n.advertise<trajectory_msgs::JointTrajectory>("/arm_controller/command",1);</font>{}
387:<font color="#FF0000">	ros::Subscriber sub = n.subscribe("/joint_states", 1, controllerStateCallback);</font>{}
388:<font color="#FF0000">	ros::Subscriber sub_vc = n.subscribe("/arm_controller/command_vel", 1, velocityCallback);</font>{}
389:<font color="#FF0000">	serv_reset = n.advertiseService("reset_brics_interface", resetCB);</font>{}
390:<font color="#FF0000">	ros::spin();</font>{}
391:	return 0;
392:<font color="#FF0000">    ros::NodeHandle n_;</font>{}
393:<font color="#FF0000">    ros::Publisher joint_vel_pub_;</font>{}
394:<font color="#FF0000">    ros::Subscriber controller_state_;</font>{}
395:<font color="#FF0000"> 	ros::Subscriber operation_mode_;</font>{}
396:<font color="#FF0000"> 	ros::ServiceServer srvServer_Stop_;</font>{}
397:<font color="#FF0000">    ros::ServiceServer srvServer_SetVel_;</font>{}
398:<font color="#FF0000">    ros::ServiceServer srvServer_SetAcc_;</font>{}
399:<font color="#FF0000"> 	ros::ServiceClient srvClient_SetOperationMode;</font>{}
400:<font color="#FF0000">    actionlib::SimpleActionServer<control_msgs::FollowJointTrajectoryAction> as_follow_;</font>{}
401:    std::string action_name_follow_;
402:    std::string current_operation_mode_;
403:    XmlRpc::XmlRpcValue JointNames_param_;
404:    std::vector<std::string> JointNames_;
405:    bool executing_;
406:    bool failure_;
407:    bool rejected_;
408:  bool preemted_;
409:    int DOF;
410:    double velocity_timeout_;
411:  	int watchdog_counter;
412:    genericArmCtrl* traj_generator_;
413:    trajectory_msgs::JointTrajectory traj_;
414:    trajectory_msgs::JointTrajectory traj_2_;
415:    std::vector<double> q_current, startposition_, joint_distance_;
416:<font color="#FF0000">		joint_vel_pub_ = n_.advertise<brics_actuator::JointVelocities>("command_vel", 1);</font>{}
417:<font color="#FF0000">        controller_state_ = n_.subscribe("state", 1, &cob_trajectory_controller_node::state_callback, this);</font>{}
418:<font color="#FF0000">		operation_mode_ = n_.subscribe("current_operationmode", 1, &cob_trajectory_controller_node::operationmode_callback, this);</font>{}
419:<font color="#FF0000">		srvServer_Stop_ = n_.advertiseService("stop", &cob_trajectory_controller_node::srvCallback_Stop, this);</font>{}
420:<font color="#FF0000">        srvServer_SetVel_ = n_.advertiseService("set_joint_velocity", &cob_trajectory_controller_node::srvCallback_setVel, this);</font>{}
421:<font color="#FF0000">        srvServer_SetAcc_ = n_.advertiseService("set_joint_acceleration", &cob_trajectory_controller_node::srvCallback_setAcc, this);</font>{}
422:<font color="#FF0000">		srvClient_SetOperationMode = n_.serviceClient<cob_srvs::SetOperationMode>("set_operation_mode");</font>{}
423:		    ROS_INFO("Waiting for operationmode service to become available");
424:		      sleep(1);
425:        executing_ = false;
426:        failure_ = false;
427:        rejected_ = false;
428:	preemted_ = false;
429:		watchdog_counter = 0;
430:		current_operation_mode_ = "undefined";
431:		double PTPvel = 0.7;
432:		double PTPacc = 0.2;
433:		double maxError = 0.7;
434:		double overlap_time = 0.4;
435:        velocity_timeout_ = 2.0;
436:		DOF = 7;
437:                ROS_INFO("getting JointNames from parameter server");
438:<font color="#00FF00">                	n_.getParam("joint_names", JointNames_param_);</font>{}
439:                        ROS_ERROR("Parameter joint_names not set");
440:                JointNames_.resize(JointNames_param_.size());
441:                for (int i = 0;
442:                for (int i = 0; i<JointNames_param_.size();
443:                	JointNames_[i] = (std::string)JointNames_param_[i];
444:		DOF = JointNames_param_.size();
445:<font color="#00FF00">			n_.getParam("ptp_vel", PTPvel);</font>{}
446:<font color="#00FF00">			n_.getParam("ptp_acc", PTPacc);</font>{}
447:<font color="#00FF00">			n_.getParam("max_error", maxError);</font>{}
448:<font color="#00FF00">		    n_.getParam("overlap_time", overlap_time);</font>{}
449:		q_current.resize(DOF);
450:		ROS_INFO("starting controller with DOF: %d PTPvel: %f PTPAcc: %f maxError %f", DOF, PTPvel, PTPacc, maxError);
451:		traj_generator_ = new genericArmCtrl(DOF, PTPvel, PTPacc, maxError);
452:		traj_generator_->overlap_time = overlap_time;
453:    double frequency;
454:<font color="#00FF00">        n_.getParam("frequency", frequency);</font>{}
455:        ROS_INFO("Setting controller frequency to %f HZ", frequency);
456:        frequency = 100;
457:        ROS_WARN("Parameter frequency not available, setting to default value: %f Hz", frequency);
458:      return frequency;
459:		ROS_INFO("Stopping trajectory controller.");
460:		executing_ = false;
461:		res.success.data = true;
462:		traj_generator_->isMoving = false;
463:		failure_ = true;
464:		return true;
465:        ROS_INFO("Setting velocity to %f", req.value.data);
466:        traj_generator_->SetPTPvel(req.value.data);
467:        res.success.data = true;
468:        return true;
469:        ROS_INFO("Setting acceleration to %f", req.value.data);
470:        traj_generator_->SetPTPacc(req.value.data);
471:        res.success.data = true;
472:        return true;
473:    current_operation_mode_ = message->data;
474:    std::vector<double> positions = message->actual.positions;
475:    for(unsigned int i = 0;
476:    for(unsigned int i = 0; i < positions.size();
477:      q_current[i] = positions[i];
478:          cob_srvs::SetOperationMode opmode;
479:          opmode.request.operation_mode.data = "velocity";
480:          srvClient_SetOperationMode.call(opmode);
481:          ros::Time begin = ros::Time::now();
482:             ROS_INFO("waiting for component to go to velocity mode");
483:             usleep(100000);
484:               rejected_ = true;
485:               return;
486:	  std::vector<double> traj_start;
487:	      ROS_INFO("There is a old trajectory currently running");
488:	      traj_start = traj_generator_->last_q;
489:	      trajectory_msgs::JointTrajectory temp_traj;
490:		  temp_traj = trajectory;
491:		  trajectory_msgs::JointTrajectoryPoint p;
492:		  p.positions.resize(DOF);
493:		  p.velocities.resize(DOF);
494:		  p.accelerations.resize(DOF);
495:		  for(int i = 0;
496:		  for(int i = 0; i<DOF;
497:			  p.positions.at(i) = traj_start.at(i);
498:			  p.velocities.at(i) = 0.0;
499:			  p.accelerations.at(i) = 0.0;
500:		  std::vector<trajectory_msgs::JointTrajectoryPoint>::iterator it;
501:		  it = temp_traj.points.begin();
502:		  temp_traj.points.insert(it,p);
503:		  for(int i = 0;
504:		  for(int i = 0; i<DOF;
505:			  p.positions.at(i) = traj_generator_->last_q1.at(i);
506:			  p.velocities.at(i) = 0.0;
507:			  p.accelerations.at(i) = 0.0;
508:		  it = temp_traj.points.begin();
509:		  temp_traj.points.insert(it,p);
510:		  for(int i = 0;
511:		  for(int i = 0; i<DOF;
512:			  p.positions.at(i) = traj_generator_->last_q2.at(i);
513:			  p.velocities.at(i) = 0.0;
514:			  p.accelerations.at(i) = 0.0;
515:		  it = temp_traj.points.begin();
516:		  temp_traj.points.insert(it,p);
517:		  for(int i = 0;
518:		  for(int i = 0; i<DOF;
519:			  p.positions.at(i) = traj_generator_->last_q3.at(i);
520:			  p.velocities.at(i) = 0.0;
521:			  p.accelerations.at(i) = 0.0;
522:		  it = temp_traj.points.begin();
523:		  temp_traj.points.insert(it,p);
524:		  for(int i = 0;
525:		  for(int i = 0; i<DOF;
526:			  p.positions.at(i) = q_current.at(i);
527:			  p.velocities.at(i) = 0.0;
528:			  p.accelerations.at(i) = 0.0;
529:		  it = temp_traj.points.begin();
530:		  temp_traj.points.insert(it,p);
531:		  traj_generator_->isMoving = false ;
532:		  traj_generator_->moveTrajectory(temp_traj, traj_start);
533:	      traj_start = q_current;
534:	      trajectory_msgs::JointTrajectory temp_traj;
535:		  temp_traj = trajectory;
536:			  traj_generator_->isMoving = false ;
537:			  traj_generator_->moveThetas(temp_traj.points[0].positions, traj_start);
538:			  trajectory_msgs::JointTrajectoryPoint p;
539:			  p.positions.resize(DOF);
540:			  p.velocities.resize(DOF);
541:			  p.accelerations.resize(DOF);
542:			  for(int i = 0;
543:			  for(int i = 0; i<DOF;
544:				  p.positions.at(i) = traj_start.at(i);
545:				  p.velocities.at(i) = 0.0;
546:				  p.accelerations.at(i) = 0.0;
547:			  std::vector<trajectory_msgs::JointTrajectoryPoint>::iterator it;
548:			  it = temp_traj.points.begin();
549:			  temp_traj.points.insert(it,p);
550:			  traj_generator_->isMoving = false ;
551:			  traj_generator_->moveTrajectory(temp_traj, traj_start);
552:	    executing_ = true;
553:            startposition_ = q_current;
554:	    preemted_ = false;
555:            usleep(1000);
556:		  return;
557:        ROS_INFO("Received new goal trajectory with %d points",goal->trajectory.points.size());
558:        spawnTrajector(goal->trajectory);
559:            as_follow_.setAborted();
560:                as_follow_.setAborted();
561:                as_follow_.setSucceeded();
562:        rejected_ = false;
563:        failure_ = false;
564:            failure_ = false;
565:	        watchdog_counter = 0;
566:				executing_ = false;
567:				traj_generator_->isMoving = false;
568:                failure_ = true;
569:		return;
570:			    failure_ = true;
571:			    preemted_ = true;
572:			    ROS_INFO("Preempted trajectory action");
573:			    return;
574:        	std::vector<double> des_vel;
575:        			executing_ = false;
576:				preemted_ = false;
577:				brics_actuator::JointVelocities target_joint_vel;
578:				target_joint_vel.velocities.resize(DOF);
579:				for(int i=0;
580:				for(int i=0; i<DOF;
581:					target_joint_vel.velocities[i].joint_uri = JointNames_[i].c_str();
582:					target_joint_vel.velocities[i].unit = "rad";
583:					target_joint_vel.velocities[i].value = des_vel.at(i);
584:<font color="#FF0000">				joint_vel_pub_.publish(target_joint_vel);</font>{}
585:        		ROS_INFO("An controller error occured!");
586:                failure_ = true;
587:        		executing_ = false;
588:			brics_actuator::JointVelocities target_joint_vel;
589:			target_joint_vel.velocities.resize(DOF);
590:			for (int i = 0;
591:			for (int i = 0; i < DOF;
592:				target_joint_vel.velocities[i].joint_uri = JointNames_[i].c_str();
593:				target_joint_vel.velocities[i].unit = "rad";
594:				target_joint_vel.velocities[i].value = 0;
595:<font color="#FF0000">				joint_vel_pub_.publish(target_joint_vel);</font>{}
596:		  watchdog_counter++;
597:};
598:<font color="#FF0000">    ros::init(argc, argv, "cob_trajectory_controller");</font>{}
599:    cob_trajectory_controller_node tm;
600:    double frequency = tm.getFrequency();
601:    ros::Rate loop_rate(frequency);
602:        tm.run();
603:<font color="#FF0000">        ros::spinOnce();</font>{}
604:        loop_rate.sleep();
</pre>
</body>
</html>
