<html>
<body>
    <table summary="code examples">
 
        <tr>

        <td><pre style="border: 1px solid #888;padding: 2px">
1:using namespace Magick;
2:  width = image.columns();
3:  height = image.rows();
4:  return width;
5:  return height;
6:  const Magick::PixelPacket* pixel_cache = image_.getConstPixels(0, y, width, 1);
7:  int width = getWidth();
8:    row = new unsigned char[width];
9:  for (int x = 0;
10:  for (int x = 0; x < width;
11:    const PixelPacket* p = pixel_cache + x;
12:        117 * ((int)p->blue >> 8) + 0x200) >> 10);
13:  return row;
14:  const Magick::PixelPacket* pixel_cache = image_.getConstPixels(0, 0, width, height);
15:  int width = getWidth();
16:  int height =  getHeight();
17:  unsigned char* matrix = new unsigned char[width*height];
18:  unsigned char* m = matrix;
19:  const Magick::PixelPacket* p = pixel_cache;
20:  for (int y = 0;
21:  for (int y = 0; y < height;
22:    for (int x = 0;
23:    for (int x = 0; x < width;
24:          117 * ((int)p->blue >> 8) + 0x200) >> 10);
25:      m++;
26:      p++;
27:  return matrix;
28:  return true;
29:  Magick::Image rotated(image_);
30:  rotated.modifyImage();
31:  rotated.rotate(90);
32:  rotated.syncPixels();
33:  return Ref<MagickBitmapSource> (new MagickBitmapSource(rotated));
34:  return true;
35:  Image copy(image_);
36:  copy.modifyImage();
37:  copy.crop( Geometry(width,height,left,top));
38:  copy.syncPixels();
39:  return Ref<MagickBitmapSource>(new MagickBitmapSource(copy));
40:<font color="#FF0000">  ros::NodeHandle n_;</font>{}
41:  virtual void onInit()=0;
42:};
43:<font color="#FF0000">  ros::NodeHandle n_;</font>{}
44:    PCLNodelet::onInit();
45:    n_ = getNodeHandle();
46:};
47:  typedef pcl::PointCloud<pcl::PointXYZ> PointCloud;
48:  typedef message_filters::sync_policies::ApproximateTime<sensor_msgs::Image,sensor_msgs::PointCloud2> MySyncPolicy;
49:<font color="#FF0000">  typedef actionlib::SimpleActionServer<cob_object_detection_msgs::DetectObjectsAction> ActionServer;</font>{}
50:<font color="#FF0000">  message_filters::Subscriber<sensor_msgs::Image> visual_sub_ ;</font>{}
51:<font color="#FF0000">  message_filters::Subscriber<sensor_msgs::PointCloud2> point_cloud_sub_;</font>{}
52:  message_filters::Synchronizer<MySyncPolicy> *sync_;
53:<font color="#FF0000">  ActionServer *as_;</font>{}
54:  cob_object_detection_msgs::DetectObjectsResult result_;
55:  boost::mutex mutex_;
56:<font color="#FF0000">  ros::Subscriber img_sub_;</font>{}
57:<font color="#FF0000">  ros::Publisher  detection_pub_;</font>{}
58:<font color="#FF0000">  ros::Publisher test_pub_;</font>{}
59:<font color="#FF0000">  tf::TransformBroadcaster br_;</font>{}
60:  GeneralMarker *gm_;
61:  typedef enum {MARKER_3D, MARKER_2D, MARKER_2D_CALIB} MARKER_TYPE;
62:  MARKER_TYPE marker_type_;
63:  double f_;
64:  double marker_size_;
65:<font color="#FF0000">    visual_sub_.subscribe();</font>{}
66:<font color="#FF0000">    point_cloud_sub_.subscribe();</font>{}
67:<font color="#FF0000">    visual_sub_.unsubscribe();</font>{}
68:<font color="#FF0000">    point_cloud_sub_.unsubscribe();</font>{}
69:    PointCloud tmp;
70:    for(int x=0;
71:    for(int x=0; x<w;
72:      Eigen::Vector2i p = o + (d*x).cast<int>();
73:        tmp.push_back( pc(p(0),p(1)) );
74:      ROS_WARN("no valid points");
75:      return false;
76:    pca.compute(tmp);
77:    return true;
78:    delete sync_;
79:    delete gm_;
80:    this->start();
81:<font color="#FF0000">    ros::NodeHandle *n=&(this->n_);</font>{}
82:    std::string type;
83:        marker_type_ = MARKER_2D;
84:        marker_type_ = MARKER_2D_CALIB;
85:<font color="#00FF00">    n->getParam("marker_size",marker_size_);</font>{}
86:<font color="#00FF00">    n->getParam("f",f_);</font>{}
87:<font color="#FF0000">      visual_sub_.subscribe(*n,"/camera/rgb/image_color",2);</font>{}
88:<font color="#FF0000">      point_cloud_sub_.subscribe(*n,"/camera/depth/points",2);</font>{}
89:      sync_ = new message_filters::Synchronizer<MySyncPolicy>(MySyncPolicy(4), visual_sub_, point_cloud_sub_);
90:      sync_->registerCallback(boost::bind(&Qr_Node::callback_synchronizer, this, _1, _2));
91:<font color="#FF0000">      img_sub_ = n->subscribe("/camera/rgb/image_color", 2, &Qr_Node::callback_img, this);</font>{}
92:<font color="#FF0000">    unsubscribe();</font>{}
93:<font color="#FF0000">    as_ = new ActionServer(*n, "object_detection", boost::bind(&Qr_Node::executeCB, this, _1), false);</font>{}
94:    as_->start();
95:<font color="#FF0000">    test_pub_ = n->advertise<std_msgs::String>("marker_callback",1);</font>{'type': 'std_msgs::String', 'name': 'marker_callback'}
96:    std::string algo_;
97:        gm_ = new Marker_Zxing();
98:        bool tryHarder;
99:          dynamic_cast<Marker_Zxing*>(gm_)->setTryHarder(tryHarder);
100:        gm_ = new Marker_DMTX();
101:        int dmtx_timeout_;
102:        n->param<int>("dmtx_timeout",dmtx_timeout_,500);
103:        dynamic_cast<Marker_DMTX*>(gm_)->setTimeout(dmtx_timeout_);
104:      ROS_ERROR("no algorithm was selected\npossible candidates are:\n\t- zxing\n\t- dmtx\n");
105:    ros::Rate r(10);
106:    bool success = false;
107:      return;
108:<font color="#FF0000">    subscribe();</font>{}
109:    ROS_INFO("Action called");
110:    double time_start = ros::Time::now().toSec();
111:    const double timeout = 20;
112:      mutex_.lock();
113:      for(size_t i=0;
114:      for(size_t i=0; i<result_.object_list.detections.size();
115:          ROS_INFO("Marker %s found", result_.object_list.detections[i].label.c_str());
116:          success = true;
117:          break;
118:        break;
119:      mutex_.unlock();
120:        as_->setPreempted();
121:        break;
122:      r.sleep();
123:<font color="#FF0000">    unsubscribe();</font>{}
124:      as_->setSucceeded(result_);
125:      mutex_.unlock();
126:      as_->setAborted(result_);
127:    if(!gm_) return;
128:    double time_before_find = ros::Time::now().toSec();
129:    std::vector<GeneralMarker::SMarker> res;
130:    gm_->findPattern(*msg_image, res);
131:    ROS_DEBUG("\nfindPattern finished: runtime %f s ; %d pattern found", (ros::Time::now().toSec() - time_before_find), (int)res.size());
132:    mutex_.lock();
133:    result_.object_list.detections.clear();
134:    for(size_t i=0;
135:    for(size_t i=0; i<res.size();
136:        ROS_WARN("need 3 points");
137:        continue;
138:      Eigen::Vector2f d1 = (res[i].pts_[1]-res[i].pts_[0]).cast<float>();
139:      Eigen::Vector2f d2 = (res[i].pts_[2]-res[i].pts_[0]).cast<float>();
140:      const double l1 = d1.norm();
141:      const double l2 = d2.norm();
142:      ROS_DEBUG("Code: %s", res[i].code_.c_str());
143:      ROS_DEBUG("p1: %d %d", res[i].pts_[0](0), res[i].pts_[0](1));
144:      ROS_DEBUG("p2: %d %d", res[i].pts_[1](0), res[i].pts_[1](1));
145:      ROS_DEBUG("p3: %d %d", res[i].pts_[2](0), res[i].pts_[2](1));
146:      ROS_DEBUG("p4: %d %d", res[i].pts_[3](0), res[i].pts_[3](1));
147:      ROS_DEBUG("d1: %f %f", d1(0), d1(1));
148:      ROS_DEBUG("d2: %f %f", d2(0), d2(1));
149:      Eigen::Vector3f a,b;
150:      int i1=0;
151:      if(pca1.getEigenValues()[1]>pca1.getEigenValues()[i1]) i1=1;
152:      if(pca1.getEigenValues()[2]>pca1.getEigenValues()[i1]) i1=2;
153:      int i2=0;
154:      if(pca2.getEigenValues()[1]>pca2.getEigenValues()[i2]) i2=1;
155:      if(pca2.getEigenValues()[2]>pca2.getEigenValues()[i2]) i2=2;
156:        pca1.getEigenVectors().col(i1)*=-1;
157:        pca2.getEigenVectors().col(i2)*=-1;
158:      Eigen::Vector3f m = (pca1.getMean()+pca2.getMean()).head<3>()/2;
159:      Eigen::Matrix3f M, M2;
160:      M.col(0) = pca2.getEigenVectors().col(i2);
161:      M.col(1) = M.col(0).cross((Eigen::Vector3f)pca1.getEigenVectors().col(i1));
162:      M.col(1).normalize();
163:      M.col(2) = M.col(0).cross(M.col(1));
164:      Eigen::Quaternionf q(M);
165:      M2 = M;
166:      M2.col(1)=M.col(2);
167:      M2.col(2)=M.col(1);
168:      Eigen::Quaternionf q2(M);
169:      std::cout<<"E\n"<<pca1.getEigenVectors()<<"\n";
170:      std::cout<<"E\n"<<pca2.getEigenVectors()<<"\n";
171:      std::cout<<"E\n"<<pca1.getEigenValues()<<"\n";
172:      std::cout<<"E\n"<<pca2.getEigenValues()<<"\n";
173:      std::cout<<"M\n"<<M2<<"\n";
174:      std::cout<<"d\n"<<M.col(0).dot(M.col(1))<<"\n";
175:      std::cout<<"d\n"<<M.col(0).dot(M.col(2))<<"\n";
176:      std::cout<<"d\n"<<M.col(1).dot(M.col(2))<<"\n";
177:      cob_object_detection_msgs::Detection det;
178:      det.header = msg_depth->header;
179:      det.label = res[i].code_.substr(0,3);
180:      det.detector = gm_->getName();
181:      det.pose.header = msg_depth->header;
182:      det.pose.pose.position.x = m(0);
183:      det.pose.pose.position.y = m(1);
184:      det.pose.pose.position.z = m(2);
185:      det.pose.pose.orientation.w = q2.w();
186:      det.pose.pose.orientation.x = q2.x();
187:      det.pose.pose.orientation.y = q2.y();
188:      det.pose.pose.orientation.z = q2.z();
189:      result_.object_list.detections.push_back(det);
190:      tf::Transform transform;
191:      transform.setOrigin( tf::Vector3(m(0), m(1), m(2)) );
192:      transform.setRotation( tf::Quaternion(q.x(), q.y(), q.z(), q.w()) );
193:<font color="#FF0000">      br_.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "head_cam3d_link", res[i].code_.substr(0,3)));</font>{'to': '3', 'from': 'res[i].code_.substr(0'}
194:      ROS_ASSERT(0);
195:    mutex_.unlock();
196:    if(!gm_) return;
197:    double time_before_find = ros::Time::now().toSec();
198:    std::vector<GeneralMarker::SMarker> res;
199:    gm_->findPattern(*msg_image, res);
200:    ROS_DEBUG("\nfindPattern finished: runtime %f s ; %d pattern found", (ros::Time::now().toSec() - time_before_find), (int)res.size());
201:    PointCloud pc;
202:      pcl::fromROSMsg(*msg_depth, pc);
203:    mutex_.lock();
204:    result_.object_list.detections.clear();
205:    for(size_t i=0;
206:    for(size_t i=0; i<res.size();
207:        ROS_WARN("need 3 points");
208:        continue;
209:      Eigen::Vector2f d1 = (res[i].pts_[1]-res[i].pts_[0]).cast<float>();
210:      Eigen::Vector2f d2 = (res[i].pts_[2]-res[i].pts_[0]).cast<float>();
211:      ROS_DEBUG("Code: %s", res[i].code_.c_str());
212:      ROS_DEBUG("p1: %d %d", res[i].pts_[0](0), res[i].pts_[0](1));
213:      ROS_DEBUG("p2: %d %d", res[i].pts_[1](0), res[i].pts_[1](1));
214:      ROS_DEBUG("p3: %d %d", res[i].pts_[2](0), res[i].pts_[2](1));
215:      ROS_DEBUG("p4: %d %d", res[i].pts_[3](0), res[i].pts_[3](1));
216:      ROS_DEBUG("d1: %f %f", d1(0), d1(1));
217:      ROS_DEBUG("d2: %f %f", d2(0), d2(1));
218:      int w1=std::max(std::abs(d1(0)),std::abs(d1(1)));
219:      int w2=std::max(std::abs(d2(0)),std::abs(d2(1)));
220:      d1/=w1;
221:      d2/=w2;
222:      pcl::PCA<PointCloud::PointType> pca1, pca2;
223:        continue;
224:        continue;
225:      int i1=0;
226:      if(pca1.getEigenValues()[1]>pca1.getEigenValues()[i1]) i1=1;
227:      if(pca1.getEigenValues()[2]>pca1.getEigenValues()[i1]) i1=2;
228:      int i2=0;
229:      if(pca2.getEigenValues()[1]>pca2.getEigenValues()[i2]) i2=1;
230:      if(pca2.getEigenValues()[2]>pca2.getEigenValues()[i2]) i2=2;
231:        pca1.getEigenVectors().col(i1)*=-1;
232:        pca2.getEigenVectors().col(i2)*=-1;
233:      Eigen::Vector3f m = (pca1.getMean()+pca2.getMean()).head<3>()/2;
234:      Eigen::Matrix3f M, M2;
235:      M.col(0) = pca2.getEigenVectors().col(i2);
236:      M.col(1) = M.col(0).cross((Eigen::Vector3f)pca1.getEigenVectors().col(i1));
237:      M.col(1).normalize();
238:      M.col(2) = M.col(0).cross(M.col(1));
239:      Eigen::Quaternionf q(M);
240:      M2 = M;
241:      M2.col(1)=M.col(2);
242:      M2.col(2)=M.col(1);
243:      Eigen::Quaternionf q2(M);
244:      std::cout<<"E\n"<<pca1.getEigenVectors()<<"\n";
245:      std::cout<<"E\n"<<pca2.getEigenVectors()<<"\n";
246:      std::cout<<"E\n"<<pca1.getEigenValues()<<"\n";
247:      std::cout<<"E\n"<<pca2.getEigenValues()<<"\n";
248:      std::cout<<"M\n"<<M2<<"\n";
249:      std::cout<<"d\n"<<M.col(0).dot(M.col(1))<<"\n";
250:      std::cout<<"d\n"<<M.col(0).dot(M.col(2))<<"\n";
251:      std::cout<<"d\n"<<M.col(1).dot(M.col(2))<<"\n";
252:      cob_object_detection_msgs::Detection det;
253:      det.header = msg_depth->header;
254:      det.label = res[i].code_.substr(0,3);
255:      det.detector = gm_->getName();
256:      det.pose.header = msg_depth->header;
257:      det.pose.pose.position.x = m(0);
258:      det.pose.pose.position.y = m(1);
259:      det.pose.pose.position.z = m(2);
260:      det.pose.pose.orientation.w = q2.w();
261:      det.pose.pose.orientation.x = q2.x();
262:      det.pose.pose.orientation.y = q2.y();
263:      det.pose.pose.orientation.z = q2.z();
264:      result_.object_list.detections.push_back(det);
265:      tf::Transform transform;
266:      transform.setOrigin( tf::Vector3(m(0), m(1), m(2)) );
267:      transform.setRotation( tf::Quaternion(q.x(), q.y(), q.z(), q.w()) );
268:<font color="#FF0000">      br_.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "head_cam3d_link", res[i].code_.substr(0,3)));</font>{'to': '3', 'from': 'res[i].code_.substr(0'}
269:    mutex_.unlock();
270:};
271:<font color="#FF0000">  ros::init(argc, argv, "Qr");</font>{}
272:  Qr_Node<As_Node> sn;
273:  sn.onInit();
274:<font color="#FF0000">  ros::spin();</font>{}
275:  return 0;
</pre>
</body>
</html>
