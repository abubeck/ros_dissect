<html>
<body>
    <table summary="code examples">
 
        <tr>

        <td><pre style="border: 1px solid #888;padding: 2px">
using namespace Magick;
  width = image.columns();
  height = image.rows();
  return width;
  return height;
  const Magick::PixelPacket* pixel_cache = image_.getConstPixels(0, y, width, 1);
  int width = getWidth();
    row = new unsigned char[width];
  for (int x = 0;
  for (int x = 0; x < width;
    const PixelPacket* p = pixel_cache + x;
        117 * ((int)p->blue >> 8) + 0x200) >> 10);
  return row;
  const Magick::PixelPacket* pixel_cache = image_.getConstPixels(0, 0, width, height);
  int width = getWidth();
  int height =  getHeight();
  unsigned char* matrix = new unsigned char[width*height];
  unsigned char* m = matrix;
  const Magick::PixelPacket* p = pixel_cache;
  for (int y = 0;
  for (int y = 0; y < height;
    for (int x = 0;
    for (int x = 0; x < width;
          117 * ((int)p->blue >> 8) + 0x200) >> 10);
      m++;
      p++;
  return matrix;
  return true;
  Magick::Image rotated(image_);
  rotated.modifyImage();
  rotated.rotate(90);
  rotated.syncPixels();
  return Ref<MagickBitmapSource> (new MagickBitmapSource(rotated));
  return true;
  Image copy(image_);
  copy.modifyImage();
  copy.crop( Geometry(width,height,left,top));
  copy.syncPixels();
  return Ref<MagickBitmapSource>(new MagickBitmapSource(copy));
<font color="#FF0000">  ros::NodeHandle n_;</font>{}
  virtual void onInit()=0;
};
<font color="#FF0000">  ros::NodeHandle n_;</font>{}
    PCLNodelet::onInit();
    n_ = getNodeHandle();
};
  typedef pcl::PointCloud<pcl::PointXYZ> PointCloud;
  typedef message_filters::sync_policies::ApproximateTime<sensor_msgs::Image,sensor_msgs::PointCloud2> MySyncPolicy;
  typedef actionlib::SimpleActionServer<cob_object_detection_msgs::DetectObjectsAction> ActionServer;
  message_filters::Subscriber<sensor_msgs::Image> visual_sub_ ;
  message_filters::Subscriber<sensor_msgs::PointCloud2> point_cloud_sub_;
  message_filters::Synchronizer<MySyncPolicy> *sync_;
  ActionServer *as_;
  cob_object_detection_msgs::DetectObjectsResult result_;
  boost::mutex mutex_;
<font color="#FF0000">  ros::Subscriber img_sub_;</font>{}
<font color="#FF0000">  ros::Publisher  detection_pub_;</font>{}
<font color="#FF0000">  ros::Publisher test_pub_;</font>{}
  tf::TransformBroadcaster br_;
  GeneralMarker *gm_;
  typedef enum {MARKER_3D, MARKER_2D, MARKER_2D_CALIB} MARKER_TYPE;
  MARKER_TYPE marker_type_;
  double f_;
  double marker_size_;
    visual_sub_.subscribe();
    point_cloud_sub_.subscribe();
    visual_sub_.unsubscribe();
    point_cloud_sub_.unsubscribe();
    PointCloud tmp;
    for(int x=0;
    for(int x=0; x<w;
      Eigen::Vector2i p = o + (d*x).cast<int>();
        tmp.push_back( pc(p(0),p(1)) );
      ROS_WARN("no valid points");
      return false;
    pca.compute(tmp);
    return true;
    delete sync_;
    delete gm_;
    this->start();
<font color="#FF0000">    ros::NodeHandle *n=&(this->n_);</font>{}
    std::string type;
        marker_type_ = MARKER_2D;
        marker_type_ = MARKER_2D_CALIB;
<font color="#00FF00">    n->getParam("marker_size",marker_size_);</font>{}
<font color="#00FF00">    n->getParam("f",f_);</font>{}
      visual_sub_.subscribe(*n,"/camera/rgb/image_color",2);
      point_cloud_sub_.subscribe(*n,"/camera/depth/points",2);
      sync_ = new message_filters::Synchronizer<MySyncPolicy>(MySyncPolicy(4), visual_sub_, point_cloud_sub_);
      sync_->registerCallback(boost::bind(&Qr_Node::callback_synchronizer, this, _1, _2));
<font color="#FF0000">      img_sub_ = n->subscribe("/camera/rgb/image_color", 2, &Qr_Node::callback_img, this);</font>{}
    unsubscribe();
    as_ = new ActionServer(*n, "object_detection", boost::bind(&Qr_Node::executeCB, this, _1), false);
    as_->start();
<font color="#FF0000">    test_pub_ = n->advertise<std_msgs::String>("marker_callback",1);</font>{'type': 'std_msgs::String', 'name': 'marker_callback'}
    std::string algo_;
        gm_ = new Marker_Zxing();
        bool tryHarder;
          dynamic_cast<Marker_Zxing*>(gm_)->setTryHarder(tryHarder);
        gm_ = new Marker_DMTX();
        int dmtx_timeout_;
        n->param<int>("dmtx_timeout",dmtx_timeout_,500);
        dynamic_cast<Marker_DMTX*>(gm_)->setTimeout(dmtx_timeout_);
      ROS_ERROR("no algorithm was selected\npossible candidates are:\n\t- zxing\n\t- dmtx\n");
    ros::Rate r(10);
    bool success = false;
      return;
    subscribe();
    ROS_INFO("Action called");
    double time_start = ros::Time::now().toSec();
    const double timeout = 20;
      mutex_.lock();
      for(size_t i=0;
      for(size_t i=0; i<result_.object_list.detections.size();
          ROS_INFO("Marker %s found", result_.object_list.detections[i].label.c_str());
          success = true;
          break;
        break;
      mutex_.unlock();
        as_->setPreempted();
        break;
      r.sleep();
    unsubscribe();
      as_->setSucceeded(result_);
      mutex_.unlock();
      as_->setAborted(result_);
    if(!gm_) return;
    double time_before_find = ros::Time::now().toSec();
    std::vector<GeneralMarker::SMarker> res;
    gm_->findPattern(*msg_image, res);
    ROS_DEBUG("\nfindPattern finished: runtime %f s ; %d pattern found", (ros::Time::now().toSec() - time_before_find), (int)res.size());
    mutex_.lock();
    result_.object_list.detections.clear();
    for(size_t i=0;
    for(size_t i=0; i<res.size();
        ROS_WARN("need 3 points");
        continue;
      Eigen::Vector2f d1 = (res[i].pts_[1]-res[i].pts_[0]).cast<float>();
      Eigen::Vector2f d2 = (res[i].pts_[2]-res[i].pts_[0]).cast<float>();
      const double l1 = d1.norm();
      const double l2 = d2.norm();
      ROS_DEBUG("Code: %s", res[i].code_.c_str());
      ROS_DEBUG("p1: %d %d", res[i].pts_[0](0), res[i].pts_[0](1));
      ROS_DEBUG("p2: %d %d", res[i].pts_[1](0), res[i].pts_[1](1));
      ROS_DEBUG("p3: %d %d", res[i].pts_[2](0), res[i].pts_[2](1));
      ROS_DEBUG("p4: %d %d", res[i].pts_[3](0), res[i].pts_[3](1));
      ROS_DEBUG("d1: %f %f", d1(0), d1(1));
      ROS_DEBUG("d2: %f %f", d2(0), d2(1));
      Eigen::Vector3f a,b;
      int i1=0;
      if(pca1.getEigenValues()[1]>pca1.getEigenValues()[i1]) i1=1;
      if(pca1.getEigenValues()[2]>pca1.getEigenValues()[i1]) i1=2;
      int i2=0;
      if(pca2.getEigenValues()[1]>pca2.getEigenValues()[i2]) i2=1;
      if(pca2.getEigenValues()[2]>pca2.getEigenValues()[i2]) i2=2;
        pca1.getEigenVectors().col(i1)*=-1;
        pca2.getEigenVectors().col(i2)*=-1;
      Eigen::Vector3f m = (pca1.getMean()+pca2.getMean()).head<3>()/2;
      Eigen::Matrix3f M, M2;
      M.col(0) = pca2.getEigenVectors().col(i2);
      M.col(1) = M.col(0).cross((Eigen::Vector3f)pca1.getEigenVectors().col(i1));
      M.col(1).normalize();
      M.col(2) = M.col(0).cross(M.col(1));
      Eigen::Quaternionf q(M);
      M2 = M;
      M2.col(1)=M.col(2);
      M2.col(2)=M.col(1);
      Eigen::Quaternionf q2(M);
      std::cout<<"E\n"<<pca1.getEigenVectors()<<"\n";
      std::cout<<"E\n"<<pca2.getEigenVectors()<<"\n";
      std::cout<<"E\n"<<pca1.getEigenValues()<<"\n";
      std::cout<<"E\n"<<pca2.getEigenValues()<<"\n";
      std::cout<<"M\n"<<M2<<"\n";
      std::cout<<"d\n"<<M.col(0).dot(M.col(1))<<"\n";
      std::cout<<"d\n"<<M.col(0).dot(M.col(2))<<"\n";
      std::cout<<"d\n"<<M.col(1).dot(M.col(2))<<"\n";
      cob_object_detection_msgs::Detection det;
      det.header = msg_depth->header;
      det.label = res[i].code_.substr(0,3);
      det.detector = gm_->getName();
      det.pose.header = msg_depth->header;
      det.pose.pose.position.x = m(0);
      det.pose.pose.position.y = m(1);
      det.pose.pose.position.z = m(2);
      det.pose.pose.orientation.w = q2.w();
      det.pose.pose.orientation.x = q2.x();
      det.pose.pose.orientation.y = q2.y();
      det.pose.pose.orientation.z = q2.z();
      result_.object_list.detections.push_back(det);
      tf::Transform transform;
      transform.setOrigin( tf::Vector3(m(0), m(1), m(2)) );
      transform.setRotation( tf::Quaternion(q.x(), q.y(), q.z(), q.w()) );
<font color="#FF0000">      br_.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "head_cam3d_link", res[i].code_.substr(0,3)));</font>{'to': '3', 'from': 'res[i].code_.substr(0'}
      ROS_ASSERT(0);
    mutex_.unlock();
    if(!gm_) return;
    double time_before_find = ros::Time::now().toSec();
    std::vector<GeneralMarker::SMarker> res;
    gm_->findPattern(*msg_image, res);
    ROS_DEBUG("\nfindPattern finished: runtime %f s ; %d pattern found", (ros::Time::now().toSec() - time_before_find), (int)res.size());
    PointCloud pc;
      pcl::fromROSMsg(*msg_depth, pc);
    mutex_.lock();
    result_.object_list.detections.clear();
    for(size_t i=0;
    for(size_t i=0; i<res.size();
        ROS_WARN("need 3 points");
        continue;
      Eigen::Vector2f d1 = (res[i].pts_[1]-res[i].pts_[0]).cast<float>();
      Eigen::Vector2f d2 = (res[i].pts_[2]-res[i].pts_[0]).cast<float>();
      ROS_DEBUG("Code: %s", res[i].code_.c_str());
      ROS_DEBUG("p1: %d %d", res[i].pts_[0](0), res[i].pts_[0](1));
      ROS_DEBUG("p2: %d %d", res[i].pts_[1](0), res[i].pts_[1](1));
      ROS_DEBUG("p3: %d %d", res[i].pts_[2](0), res[i].pts_[2](1));
      ROS_DEBUG("p4: %d %d", res[i].pts_[3](0), res[i].pts_[3](1));
      ROS_DEBUG("d1: %f %f", d1(0), d1(1));
      ROS_DEBUG("d2: %f %f", d2(0), d2(1));
      int w1=std::max(std::abs(d1(0)),std::abs(d1(1)));
      int w2=std::max(std::abs(d2(0)),std::abs(d2(1)));
      d1/=w1;
      d2/=w2;
      pcl::PCA<PointCloud::PointType> pca1, pca2;
        continue;
        continue;
      int i1=0;
      if(pca1.getEigenValues()[1]>pca1.getEigenValues()[i1]) i1=1;
      if(pca1.getEigenValues()[2]>pca1.getEigenValues()[i1]) i1=2;
      int i2=0;
      if(pca2.getEigenValues()[1]>pca2.getEigenValues()[i2]) i2=1;
      if(pca2.getEigenValues()[2]>pca2.getEigenValues()[i2]) i2=2;
        pca1.getEigenVectors().col(i1)*=-1;
        pca2.getEigenVectors().col(i2)*=-1;
      Eigen::Vector3f m = (pca1.getMean()+pca2.getMean()).head<3>()/2;
      Eigen::Matrix3f M, M2;
      M.col(0) = pca2.getEigenVectors().col(i2);
      M.col(1) = M.col(0).cross((Eigen::Vector3f)pca1.getEigenVectors().col(i1));
      M.col(1).normalize();
      M.col(2) = M.col(0).cross(M.col(1));
      Eigen::Quaternionf q(M);
      M2 = M;
      M2.col(1)=M.col(2);
      M2.col(2)=M.col(1);
      Eigen::Quaternionf q2(M);
      std::cout<<"E\n"<<pca1.getEigenVectors()<<"\n";
      std::cout<<"E\n"<<pca2.getEigenVectors()<<"\n";
      std::cout<<"E\n"<<pca1.getEigenValues()<<"\n";
      std::cout<<"E\n"<<pca2.getEigenValues()<<"\n";
      std::cout<<"M\n"<<M2<<"\n";
      std::cout<<"d\n"<<M.col(0).dot(M.col(1))<<"\n";
      std::cout<<"d\n"<<M.col(0).dot(M.col(2))<<"\n";
      std::cout<<"d\n"<<M.col(1).dot(M.col(2))<<"\n";
      cob_object_detection_msgs::Detection det;
      det.header = msg_depth->header;
      det.label = res[i].code_.substr(0,3);
      det.detector = gm_->getName();
      det.pose.header = msg_depth->header;
      det.pose.pose.position.x = m(0);
      det.pose.pose.position.y = m(1);
      det.pose.pose.position.z = m(2);
      det.pose.pose.orientation.w = q2.w();
      det.pose.pose.orientation.x = q2.x();
      det.pose.pose.orientation.y = q2.y();
      det.pose.pose.orientation.z = q2.z();
      result_.object_list.detections.push_back(det);
      tf::Transform transform;
      transform.setOrigin( tf::Vector3(m(0), m(1), m(2)) );
      transform.setRotation( tf::Quaternion(q.x(), q.y(), q.z(), q.w()) );
<font color="#FF0000">      br_.sendTransform(tf::StampedTransform(transform, ros::Time::now(), "head_cam3d_link", res[i].code_.substr(0,3)));</font>{'to': '3', 'from': 'res[i].code_.substr(0'}
    mutex_.unlock();
};
<font color="#FF0000">  ros::init(argc, argv, "Qr");</font>{}
  Qr_Node<As_Node> sn;
  sn.onInit();
<font color="#FF0000">  ros::spin();</font>{}
  return 0;
</pre>
</body>
</html>
