<html>
<body>
    <table summary="code examples">
 
        <tr>

        <td><pre style="border: 1px solid #888;padding: 2px">
using namespace cob_3d_mapping;
  double fovHorFrac = sensor_fov_hor_/2;
  double fovVerFrac = sensor_fov_ver_/2;
  p_1_cam_(0) = p_0_(0) + tan(fovHorFrac)*sensor_max_range_;
  p_1_cam_(1) = p_0_(1) -tan(fovVerFrac)*sensor_max_range_;
  p_1_cam_(2) = p_0_(2) + sensor_max_range_;
  p_2_cam_(0) = -p_1_cam_(0);
  p_2_cam_(1) = p_1_cam_(1);
  p_2_cam_(2) = sensor_max_range_;
  p_3_cam_(0) = -p_1_cam_(0);
  p_3_cam_(1) = -p_1_cam_(1);
  p_3_cam_(2) = sensor_max_range_;
  p_4_cam_(0) = p_1_cam_(0);
  p_4_cam_(1) = -p_1_cam_(1);
  p_4_cam_(2) = sensor_max_range_;
  p_0_ = p_0_cam_;
  p_1_ = p_1_cam_;
  p_2_ = p_2_cam_;
  p_3_ = p_3_cam_;
  p_4_ = p_4_cam_;
using namespace cob_3d_mapping;
        return (c(1)-a(1))*(b(0)-a(0)) > (b(1)-a(1))*(c(0)-a(0));
  for(polygon_iterator it = polygons_in_.begin();
  for(polygon_iterator it = polygons_in_.begin(); it != polygons_in_.end();
    std::vector<Eigen::Vector3f> intersections;
    clipFOVandPlane(*it, intersections);
      Polygon::Ptr fov_poly(new Polygon(**it));
      fov_poly->contours.clear();
      fov_poly->holes.clear();
      fov_poly->contours.push_back(intersections);
      fov_poly->holes.push_back(false);
      (*it)->merge_difference(fov_poly);
      std::cout << "clipped poly:" << fov_poly->contours.size() << std::endl;
        polygons.push_back(fov_poly);
      polygons.push_back(*it);
  std::vector<Eigen::Vector3d> p(5);
  fov_.getFOV(p[0], p[1], p[2], p[3], p[4]);
  for( unsigned int i=1;
  for( unsigned int i=1; i<p.size();
    double div = poly->normal.cast<double>().dot(p[i]-p[0]);
    if ( div == 0 ) continue;
    double lambda = (poly->normal.cast<double>().dot(poly->centroid.topLeftCorner(3, 1).cast<double>() - p[0]))/div;
    if ( lambda > 1 || lambda < 0) continue;
    Eigen::Vector3d intersection = p[0] + lambda*(p[i]-p[0]);
    intersections.push_back(intersection.cast<float>());
  for( unsigned int i=1;
  for( unsigned int i=1; i<p.size();
    unsigned int j = i+1;
    if ( j == p.size() ) j = 1;
    double div = poly->normal.cast<double>().dot(p[j]-p[i]);
    if ( div == 0 ) continue;
    double lambda = (poly->normal.cast<double>().dot(poly->centroid.topLeftCorner(3, 1).cast<double>() - p[i]))/div;
    if ( lambda > 1  || lambda < 0) continue;
    Eigen::Vector3d intersection = p[i] + lambda*(p[j]-p[i]);
    intersections.push_back(intersection.cast<float>());
  std::cout << "found " << intersections.size() << "intersecting points for ID " << poly->id << std::endl;
    std::vector<Eigen::Vector2f> cs;
    Eigen::Vector2f cent(0,0);
    for(unsigned int i=0;
    for(unsigned int i=0; i<intersections.size();
        cs.push_back((poly->transform_from_world_to_plane * intersections[i]).head(2));
        cent = cent + (poly->transform_from_world_to_plane * intersections[i]).head(2);
    cent = cent/5;
    Eigen::Vector2f ref = (cs[0] - cent).normalized();
    std::map<double, unsigned int> angles1;
    std::map<double, unsigned int> angles2;
    for(unsigned int i=1;
    for(unsigned int i=1; i<cs.size();
        angles1.insert(std::pair<double, unsigned int>((cs[i]-cent).normalized().dot(ref),i));
        angles2.insert(std::pair<double, unsigned int>((cs[i]-cent).normalized().dot(ref),i));
    std::vector<unsigned int> sorted;
    sorted.push_back(0);
    for(std::map<double, unsigned int>::reverse_iterator it = angles1.rbegin();
    for(std::map<double, unsigned int>::reverse_iterator it = angles1.rbegin(); it != angles1.rend();
      sorted.push_back(it->second);
    for(std::map<double, unsigned int>::const_iterator it = angles2.begin();
    for(std::map<double, unsigned int>::const_iterator it = angles2.begin(); it != angles2.end();
      sorted.push_back(it->second);
    std::vector<Eigen::Vector3f> inters_temp(sorted.size());
    for(unsigned int i=0;
    for(unsigned int i=0; i<sorted.size();
      inters_temp[i] = intersections[sorted[i]];
    intersections.swap(inters_temp);
    Eigen::Vector2f c1 = (poly->transform_from_world_to_plane * intersections[0]).head(2);
    Eigen::Vector2f c2 = (poly->transform_from_world_to_plane * intersections[1]).head(2);
    Eigen::Vector2f c3 = (poly->transform_from_world_to_plane * intersections[2]).head(2);
    Eigen::Vector2f c4 = (poly->transform_from_world_to_plane * intersections[3]).head(2);
      if(ccw(c1,c3,c4)) ;
        if(ccw(c1,c2,c4)) std::swap(intersections[3],intersections[2]);
        else std::swap(intersections[0],intersections[3]);
        if(ccw(c1,c2,c4)) std::swap(intersections[1],intersections[2]);
        else std::swap(intersections[0],intersections[1]);
      else std::swap(intersections[0],intersections[2]);
using namespace tf;
using namespace cob_3d_mapping;
    config_server_.setCallback(boost::bind(&FieldOfViewNode::dynReconfCallback, this, _1, _2));
<font color="#FF0000">    fov_marker_pub_ = n_.advertise<visualization_msgs::Marker>("fov_marker",1);</font>{'type': 'visualization_msgs::Marker', 'name': 'fov_marker'}
    fov_.setSensorFoV_hor(config.sensor_fov_hor_angle);
    fov_.setSensorFoV_ver(config.sensor_fov_ver_angle);
    fov_.setSensorMaxRange(config.sensor_max_range);
    camera_frame_ = config.camera_frame;
    target_frame_ = config.target_frame;
    fov_.computeFieldOfView();
    StampedTransform st_trf;
      tf_listener_.waitForTransform(target_frame_, camera_frame_, ros::Time(0), ros::Duration(0.1));
      tf_listener_.lookupTransform(target_frame_, camera_frame_, ros::Time(0), st_trf);
      ROS_ERROR("%s",ex.what());
    Eigen::Affine3d trafo;
    TransformTFToEigen(st_trf, trafo);
    fov_.transformFOV(trafo);
    publishMarker();
    Eigen::Vector3d p_0;
    Eigen::Vector3d p_1;
    Eigen::Vector3d p_2;
    Eigen::Vector3d p_3;
    Eigen::Vector3d p_4;
    fov_.getFOV(p_0, p_1, p_2, p_3, p_4);
    visualization_msgs::Marker marker;
    marker.header.frame_id = target_frame_;
    marker.header.stamp = ros::Time::now();
    marker.action = visualization_msgs::Marker::ADD;
    marker.type = visualization_msgs::Marker::LINE_LIST;
    marker.lifetime = ros::Duration();
    marker.scale.x = 0.01;
    marker.points.resize(16);
    marker.points[0].x = p_0(0);
    marker.points[0].y = p_0(1);
    marker.points[0].z = p_0(2);
    marker.points[1].x = p_1(0);
    marker.points[1].y = p_1(1);
    marker.points[1].z = p_1(2);
    marker.points[2].x = p_0(0);
    marker.points[2].y = p_0(1);
    marker.points[2].z = p_0(2);
    marker.points[3].x = p_2(0);
    marker.points[3].y = p_2(1);
    marker.points[3].z = p_2(2);
    marker.points[4].x = p_0(0);
    marker.points[4].y = p_0(1);
    marker.points[4].z = p_0(2);
    marker.points[5].x = p_3(0);
    marker.points[5].y = p_3(1);
    marker.points[5].z = p_3(2);
    marker.points[6].x = p_0(0);
    marker.points[6].y = p_0(1);
    marker.points[6].z = p_0(2);
    marker.points[7].x = p_4(0);
    marker.points[7].y = p_4(1);
    marker.points[7].z = p_4(2);
    marker.points[8].x = p_1(0);
    marker.points[8].y = p_1(1);
    marker.points[8].z = p_1(2);
    marker.points[9].x = p_2(0);
    marker.points[9].y = p_2(1);
    marker.points[9].z = p_2(2);
    marker.points[10].x = p_2(0);
    marker.points[10].y = p_2(1);
    marker.points[10].z = p_2(2);
    marker.points[11].x = p_3(0);
    marker.points[11].y = p_3(1);
    marker.points[11].z = p_3(2);
    marker.points[12].x = p_3(0);
    marker.points[12].y = p_3(1);
    marker.points[12].z = p_3(2);
    marker.points[13].x = p_4(0);
    marker.points[13].y = p_4(1);
    marker.points[13].z = p_4(2);
    marker.points[14].x = p_4(0);
    marker.points[14].y = p_4(1);
    marker.points[14].z = p_4(2);
    marker.points[15].x = p_1(0);
    marker.points[15].y = p_1(1);
    marker.points[15].z = p_1(2);
    marker.color.r = 1.0;
    marker.color.g = 0.0;
    marker.color.b = 0.0;
    marker.color.a = 1.0;
<font color="#FF0000">    fov_marker_pub_.publish(marker);</font>{}
<font color="#FF0000">  ros::NodeHandle n_;</font>{}
<font color="#FF0000">  ros::Publisher fov_marker_pub_;</font>{}
  TransformListener tf_listener_;
  dynamic_reconfigure::Server<cob_3d_fov_segmentation::field_of_viewConfig> config_server_;
  std::string camera_frame_;
  std::string target_frame_;
  FieldOfView fov_;
};
  ros::init (argc, argv, "field_of_view");
  FieldOfViewNode fov;
  ros::Rate loop_rate(10);
    ros::spinOnce ();
    fov.transformFOV();
    loop_rate.sleep();
using namespace tf;
using namespace cob_3d_mapping;
  config_server_.setCallback(boost::bind(&FOVSegmentationNode::dynReconfCallback, this, _1, _2));
<font color="#FF0000">  shape_sub_ = n_.subscribe("shape_array_in", 10, &FOVSegmentationNode::shapeCallback, this);</font>{}
<font color="#FF0000">  shape_pub_ = n_.advertise<cob_3d_mapping_msgs::ShapeArray>("shape_array_out",1);</font>{'type': 'cob_3d_mapping_msgs::ShapeArray', 'name': 'shape_array_out'}
    fov_.setSensorFoV_hor(config.sensor_fov_hor_angle);
    fov_.setSensorFoV_ver(config.sensor_fov_ver_angle);
    fov_.setSensorMaxRange(config.sensor_max_range);
    camera_frame_ = config.camera_frame;
    target_frame_ = config.target_frame;
    fov_.computeFieldOfView();
  StampedTransform st_trf;
    tf_listener_.waitForTransform(target_frame_, camera_frame_, ros::Time(0), ros::Duration(0.1));
    tf_listener_.lookupTransform(target_frame_, camera_frame_, ros::Time(0), st_trf);
    ROS_ERROR("%s",ex.what());
  Eigen::Affine3d trafo;
  TransformTFToEigen(st_trf, trafo);
  fov_.transformFOV(trafo);
  fov_seg_.setFOV(fov_);
  std::vector<Polygon::Ptr> polys;
  for( unsigned int i=0;
  for( unsigned int i=0; i<sa->shapes.size();
    Polygon::Ptr p(new Polygon);
    fromROSMsg(sa->shapes[i], *p);
    polys.push_back(p);
  fov_seg_.setShapeArray(polys);
  std::vector<Polygon::Ptr> polys_out;
  fov_seg_.compute(polys_out);
  cob_3d_mapping_msgs::ShapeArray sa_out;
  sa_out.header = sa->header;
  for( unsigned int i=0;
  for( unsigned int i=0; i<polys_out.size();
    cob_3d_mapping_msgs::Shape s;
    s.header = sa->header;
    toROSMsg(*polys_out[i], s);
    sa_out.shapes.push_back(s);
<font color="#FF0000">  shape_pub_.publish(sa_out);</font>{}
  ros::init (argc, argv, "fov_segmentation_node");
  FOVSegmentationNode fov;
  ros::Rate loop_rate(10);
    ros::spinOnce ();
    loop_rate.sleep();
</pre>
</body>
</html>
