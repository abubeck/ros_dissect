<html>
<body>
    <table summary="code examples">
 
        <tr>

        <td><pre style="border: 1px solid #888;padding: 2px">
1:    count++;
2:    rects.push_back(r);
3:    texts.push_back(t);
4:  std::string img_name;
5:  std::vector<cv::Rect> rects;
6:  std::vector<std::string> texts;
7:  static int count;
8:};
9:int img::count = 0;
10:    return atoi((output.substr(output.find(label) + label.length() + 1, output.length() - 2 - label.length())).c_str());
11:    return -1;
12:  for (int i = 0;
13:  for (int i = 0; i < images.size();
14:    img * im = new img(images[i].img_name);
15:    ocrImages.push_back(*im);
16:    std::string imgpath = path.substr(0, path.find_last_of("/") + 1);
17:    imgpath.append(images[i].img_name);
18:        + " $(rospack find read_text)/fonts/correlation.txt $(rospack find read_text)/dictionary/full-dictionary";
19:    std::ifstream ocrfile;
20:    std::string textname = images[i].img_name.substr(0, images[i].img_name.find_last_of(".")) + ".txt";
21:    ocrfile.open(textname.c_str());
22:      std::cout << "While opening read_text results file an error is encountered" << std::endl;
23:      return -1;
24:    std::string input;
25:      for (int a = 0;
26:      for (int a = 0; !ocrfile.eof();
27:        ocrfile >> input;
28:        static int x, y, width, height;
29:          x = atoi(input.c_str());
30:          y = atoi(input.c_str());
31:          width = atoi(input.c_str());
32:          height = atoi(input.c_str());
33:          cv::Rect * r = new cv::Rect(x, y, width, height);
34:          ocrImages[img::count - 1].setRect(*r);
35:      ocrfile.close();
36:    textname = images[i].img_name.substr(0, images[i].img_name.find_last_of(".")) + "t.txt";
37:    ocrfile.open(textname.c_str());
38:      std::cout << "While opening read_text results file an error is encountered" << std::endl;
39:      return -1;
40:      std::string s;
41:        ocrImages[img::count - 1].setText(s);
42:  return 0;
43:  std::string label[] = {"<imageName>", "x=", "y=", "width=", "height=", "text="};
44:  std::ifstream imgxml;
45:  imgxml.open(filename.c_str());
46:      std::string filename;
47:      int x, y, width, height;
48:      std::string text;
49:      std::string output;
50:      imgxml >> output;
51:            = output.substr(output.find(label[0]) + label[0].length(), output.length() - 2 * label[0].length() - 1);
52:        img * i = new img(filename);
53:        images.push_back(*i);
54:        x = cutout(label[1], output);
55:        y = cutout(label[2], output);
56:        width = cutout(label[3], output);
57:        height = cutout(label[4], output);
58:        text = output.substr(output.find(label[5]) + label[5].length() + 1, output.length() - label[5].length() - 2);
59:        cv::Rect * r = new cv::Rect(x, y, width, height);
60:        images[img::count - 1].setRect(*r);
61:        images[img::count - 1].setText(text);
62:    imgxml.close();
63:  std::vector<cv::Rect>::iterator it;
64:  for (int h = 0;
65:  for (int h = 0; h < ocrImages.size();
66:    for (int i = 0;
67:    for (int i = 0; i < ocrImages[h].rects.size();
68:      for (int j = i + 1;
69:      for (int j = i + 1; j < ocrImages[h].rects.size();
70:          it = find(ocrImages[h].rects.begin(), ocrImages[h].rects.end(), ocrImages[h].rects[j]);
71:          ocrImages[h].rects.erase(it);
72:  for (int h = 0;
73:  for (int h = 0; h < ocrImages.size();
74:    std::string imgpath = path.substr(0, path.find_last_of("/") + 1);
75:    imgpath.append(ocrImages[h].img_name);
76:    cv::Mat OriginalImage_ = cv::imread(imgpath);
77:    cv::Mat Image_(OriginalImage_.rows, OriginalImage_.cols + 600, OriginalImage_.type());
78:    Image_.setTo(cv::Scalar(0, 0, 0, 0));
79:    cv::Mat roi = cv::Mat(Image_, cv::Rect(cv::Point(0, 0), OriginalImage_.size()));
80:    OriginalImage_.copyTo(roi);
81:                cv::FONT_HERSHEY_SIMPLEX, 0.75, cv::Scalar(255, 0, 0, 0), 1.5, 8, false);
82:                cv::Scalar(0, 255, 0, 0), 1.5, 8, false);
83:                cv::Scalar(0, 0, 255, 0), 1.5, 8, false);
84:             cv::Scalar(50, 50, 50, 0), 1, 1, 0);
85:    for (int i = 0;
86:    for (int i = 0; i < ocrImages[h].rects.size();
87:                        + ocrImages[h].rects[i].height), cvScalar((255 - 10 * i), (0), (0)), 2);
88:      std::string output;
89:      std::stringstream out;
90:          << ocrImages[h].rects[i].width << " | " << ocrImages[h].rects[i].height << " ]";
91:      output = out.str();
92:                  cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar((255 - 10 * i), 0, 0, 0), 1.5, 8, false);
93:    for (int i = 0;
94:    for (int i = 0; i < images[h].rects.size();
95:                                                                                                  (0)), 2);
96:      std::string output;
97:      std::stringstream out;
98:          << " | " << images[h].rects[i].height << " ]";
99:      output = out.str();
100:                  cv::Scalar(0, (255 - 50 * i), 0, 0), 1.5, 8, false);
101:    cv::imshow(ocrImages[h].img_name, Image_);
102:    cv::waitKey(0);
103:  for (int i = 0;
104:  for (int i = 0; i < images.size();
105:    std::cout << images[i].img_name << ":" << std::endl;
106:    for (int j = 0;
107:    for (int j = 0; j < images[i].rects.size();
108:          << images[i].rects[j].height << " [" << images[i].texts[j] << "]" << std::endl;
109:  for (int i = 0;
110:  for (int i = 0; i < images.size();
111:    std::cout << ocrImages[i].img_name << ":" << std::endl;
112:    for (int j = 0;
113:    for (int j = 0; j < ocrImages[i].rects.size();
114:          << "|" << ocrImages[i].rects[j].height << " [" << ocrImages[i].texts[j] << "]" << std::endl;
115:  for (int i = 0;
116:  for (int i = 0; i < ocrImages.size();
117:    int retrieved = (int)ocrImages[i].rects.size();
118:    int relevant = (int)images[i].rects.size();
119:    for (int j = 0;
120:    for (int j = 0; j < ocrImages[i].rects.size();
121:      for (int k = 0;
122:      for (int k = 0; k < images[i].rects.size();
123:          int intersectionPixels = (ocrImages[i].rects[j] & images[i].rects[k]).area();
124:          unsigned int percent = (intersectionPixels / (images[i].rects[k].area())) * 100;
125:                * 100;
126:          std::string output;
127:          std::stringstream out;
128:          out << "overlap: correct[" << i << "] & found[" << j << "]: " << percent << "%";
129:    ROS_ERROR( "not enought input: eval_read_text <img_list.xml>");
130:    return 1;
131:  std::vector<img> images;
132:  std::vector<img> ocrImages;
133:  readInSolution(images, argv[1]);
134:  img::count = 0;
135:  readInEstimates(images, ocrImages, argv[1]);
136:  calculateResults(images, ocrImages);
137:  showRects(images, ocrImages, argv[1]);
138:  return 0;
139:		<< endl;
140:		return -1;
141:	DetectText detector = DetectText();
142:	detector.readLetterCorrelation(argv[2]);
143:	detector.readWordList(argv[3]);
144:	detector.detect(string(argv[1]));
145:	return 0;
146:using namespace cv;
147:using namespace std;
148:  filename_ = filename;
149:  originalImage_ = imread(filename_);
150:    ROS_ERROR("Cannot read image input...");
151:    return;
152:  mode_ = IMAGE;
153:  detect();
154:  filename_ = string("streaming.jpg");
155:  originalImage_ = image;
156:  mode_ = STREAM;
157:  detect();
158:  double start_time;
159:  double time_in_seconds;
160:  start_time = clock();
161:  Mat imGray(originalImage_.size(), CV_8UC1, Scalar(0));
162:  cvtColor(originalImage_, imGray, CV_RGB2GRAY);
163:  boundingBoxes_.clear();
164:  boxesBothSides_.clear();
165:  wordsBothSides_.clear();
166:  boxesScores_.clear();
167:  preprocess(imGray);
168:  firstPass_ = true;
169:  pipeline(1);
170:  cout << "Second pass" << endl;
171:  firstPass_ = false;
172:  pipeline(-1);
173:  overlapBoundingBoxes(boundingBoxes_);
174:  ocrRead(boundingBoxes_);
175:  showBoundingBoxes(boxesBothSides_);
176:  std::cout << "1\n";
177:  overlayText(boxesBothSides_, wordsBothSides_);
178:  std::cout << "1\n";
179:    ofstream myfile, myfile2;
180:    std::string textname = outputPrefix_ + ".txt";
181:    std::string textname2 = outputPrefix_ + "t.txt";
182:    myfile.open(textname.c_str());
183:    for (int i = 0;
184:    for (int i = 0; i < boxesBothSides_.size();
185:          << boxesBothSides_[i].height << "\n";
186:    myfile.close();
187:    myfile2.open(textname2.c_str());
188:    for (int i = 0;
189:    for (int i = 0; i < wordsBothSides_.size();
190:      myfile2 << wordsBothSides_[i] << "\n";
191:    myfile2.close();
192:  imwrite(outputPrefix_ + "_detection.jpg", detection_);
193:  time_in_seconds = (clock() - start_time) / (double)CLOCKS_PER_SEC;
194:  cout << time_in_seconds << "s total in process\n" << endl;
195:  textDisplayOffset_ = 1;
196:  int maxStrokeWidthParameter = 50;
197:  maxLetterHeight_ = 300;
198:  minLetterHeight_ = 5;
199:  cout << "preprocessing: " << filename_ << endl;
200:  cout << "image size:" << image.cols << "X" << image.rows << endl;
201:  int slashIndex = -1;
202:  int dotIndex = -1;
203:  for (size_t i = filename_.length() - 1;
204:  for (size_t i = filename_.length() - 1; i != 0;
205:      dotIndex = i;
206:      slashIndex = i;
207:  outputPrefix_ = filename_.substr(slashIndex + 1, dotIndex - slashIndex - 1);
208:  cout << "outputPrefix: " << outputPrefix_ << endl;
209:  image_ = image;
210:  maxStrokeWidth_ = round((float)(max(image.cols, image.rows)) / maxStrokeWidthParameter);
211:  initialStrokeWidth_ = maxStrokeWidth_ * 2;
212:  IplImage *img2 = new IplImage(originalImage_);
213:  IplImage *img1 = cvCreateImage(cvSize(image.cols + 600, image.rows), img2->depth, img2->nChannels);
214:  cvSet(img1, cvScalar(0, 0, 0));
215:  cvSetImageROI(img1, cvRect(0, 0, image.cols, image.rows));
216:  cvCopy(img2, img1, NULL);
217:  cvResetImageROI(img1);
218:  detection_ = Mat(img1).clone();
219:  cvReleaseImage(&img1);
220:  delete img1;
221:  delete img2;
222:  return detection_;
223:  return wordsBothSides_;
224:  return boxesBothSides_;
225:    fontColor_ = BRIGHT;
226:    fontColor_ = DARK;
227:    cout << "blackwhite should only be +/-1" << endl;
228:    assert(false);
229:  double start_time;
230:  double time_in_seconds;
231:  start_time = clock();
232:  Mat swtmap(image_.size(), CV_32FC1, Scalar(initialStrokeWidth_));
233:  strokeWidthTransform(image_, swtmap, blackWhite);
234:  time_in_seconds = (clock() - start_time) / (double)CLOCKS_PER_SEC;
235:  cout << time_in_seconds << "s in strokeWidthTransform" << endl;
236:  start_time = clock();
237:  Mat ccmap(image_.size(), CV_32FC1, Scalar(-1));
238:  componentsRoi_.clear();
239:  nComponent_ = connectComponentAnalysis(swtmap, ccmap);
240:  time_in_seconds = (clock() - start_time) / (double)CLOCKS_PER_SEC;
241:  cout << time_in_seconds << "s in connectComponentAnalysis" << endl;
242:  start_time = clock();
243:  identifyLetters(swtmap, ccmap);
244:  time_in_seconds = (clock() - start_time) / (double)CLOCKS_PER_SEC;
245:  cout << time_in_seconds << "s in identifyLetters" << endl;
246:  start_time = clock();
247:  groupLetters(swtmap, ccmap);
248:  time_in_seconds = (clock() - start_time) / (double)CLOCKS_PER_SEC;
249:  cout << time_in_seconds << "s in groupLetters" << endl;
250:  start_time = clock();
251:  chainPairs(ccmap);
252:  time_in_seconds = (clock() - start_time) / (double)CLOCKS_PER_SEC;
253:  cout << time_in_seconds << "s in chainPairs" << endl;
254:  start_time = clock();
255:  time_in_seconds = (clock() - start_time) / (double)CLOCKS_PER_SEC;
256:  cout << time_in_seconds << "s in findRotationsangles" << endl;
257:  disposal();
258:  cout << "finish clean up" << endl;
259:    Canny(image_, edgemap_, 50, 120);
260:    Mat dx, dy;
261:    Sobel(image_, dx, CV_32FC1, 1, 0, 3);
262:    Sobel(image_, dy, CV_32FC1, 0, 1, 3);
263:    theta_ = Mat(image_.size(), CV_32FC1);
264:      edgepoints_.clear();
265:    for (int y = 0;
266:    for (int y = 0; y < edgemap_.rows;
267:      for (int x = 0;
268:      for (int x = 0; x < edgemap_.cols;
269:          theta_.at<float> (y, x) = atan2(dy.at<float> (y, x), dx.at<float> (y, x));
270:          edgepoints_.push_back(Point(x, y));
271:  vector<Point> strokePoints;
272:  updateStrokeWidth(swtmap, edgepoints_, strokePoints, searchDirection, UPDATE);
273:  updateStrokeWidth(swtmap, strokePoints, strokePoints, searchDirection, REFINE);
274:  vector<Point>::iterator itr = startPoints.begin();
275:  vector<Point> pointStack;
276:  vector<float> SwtValues;
277:  for (;
278:  for (; itr != startPoints.end();
279:    pointStack.clear();
280:    SwtValues.clear();
281:    float step = 1;
282:    float iy = (*itr).y;
283:    float ix = (*itr).x;
284:    float currY = iy;
285:    float currX = ix;
286:    bool isStroke = false;
287:    float iTheta = theta_.at<float> (*itr);
288:    pointStack.push_back(Point(currX, currY));
289:    SwtValues.push_back(swtmap.at<float> (currY, currX));
290:      float nextY = round(iy + sin(iTheta) * searchDirection * step);
291:      float nextX = round(ix + cos(iTheta) * searchDirection * step);
292:        break;
293:      step = step + 1;
294:        continue;
295:      currY = nextY;
296:      currX = nextX;
297:      pointStack.push_back(Point(currX, currY));
298:      SwtValues.push_back(swtmap.at<float> (currY, currX));
299:        float jTheta = theta_.at<float> (currY, currX);
300:          isStroke = true;
301:            strokePoints.push_back(Point(ix, iy));
302:        break;
303:      float newSwtVal;
304:        newSwtVal = sqrt((currY - iy) * (currY - iy) + (currX - ix) * (currX - ix));
305:        nth_element(SwtValues.begin(), SwtValues.begin() + SwtValues.size() / 2, SwtValues.end());
306:        newSwtVal = SwtValues[SwtValues.size() / 2];
307:      for (size_t i = 0;
308:      for (size_t i = 0; i < pointStack.size();
309:        swtmap.at<float> (pointStack[i]) = min(swtmap.at<float> (pointStack[i]), newSwtVal);
310:  for (int y = 0;
311:  for (int y = 0; y < swtmap.rows;
312:    for (int x = 0;
313:    for (int x = 0; x < swtmap.cols;
314:        swtmap.at<float> (y, x) = 0;
315:  int ccmapInitialVal = ccmap.at<float> (0, 0);
316:  int offsetY[] = {-1, -1, -1, 0, 0, 1, 1, 1};
317:  int offsetX[] = {-1, 0, 1, -1, 1, -1, 0, 1};
318:  int nNeighbors = 8;
319:  int label = 0;
320:  int vectorSize = ccmap.rows * ccmap.cols;
321:  int *pStack = new int[vectorSize * 2];
322:  int stackPointer;
323:  int *pVector = new int[vectorSize * 2];
324:  int vectorPointer;
325:  int currentPointX;
326:  int currentPointY;
327:  for (int y = 0;
328:  for (int y = 0; y < ccmap.rows;
329:    for (int x = 0;
330:    for (int x = 0; x < ccmap.cols;
331:      bool connected = false;
332:        vectorPointer = 0;
333:        stackPointer = 0;
334:        pStack[stackPointer] = x;
335:        pStack[stackPointer + 1] = y;
336:          currentPointX = pStack[stackPointer];
337:          currentPointY = pStack[stackPointer + 1];
338:          stackPointer -= 2;
339:          pVector[vectorPointer] = currentPointX;
340:          pVector[vectorPointer + 1] = currentPointY;
341:          vectorPointer += 2;
342:          for (int i = 0;
343:          for (int i = 0; i < nNeighbors;
344:            int ny = currentPointY + offsetY[i];
345:            int nx = currentPointX + offsetX[i];
346:              continue;
347:              ccmap.at<float> (ny, nx) = -2;
348:              continue;
349:              float sw1 = swtmap.at<float> (ny, nx);
350:              float sw2 = swtmap.at<float> (y, x);
351:                ccmap.at<float> (ny, nx) = label;
352:                stackPointer += 2;
353:                pStack[stackPointer] = nx;
354:                pStack[stackPointer + 1] = ny;
355:                connected = true;
356:          int minY = ccmap.rows, minX = ccmap.cols, maxY = 0, maxX = 0;
357:          int width, height;
358:          for (int i = 0;
359:          for (int i = 0; i < vectorPointer;
360:            minY = min(minY, pVector[i + 1]);
361:            minX = min(minX, pVector[i]);
362:            maxY = max(maxY, pVector[i + 1]);
363:            maxX = max(maxX, pVector[i]);
364:          width = maxX - minX + 1;
365:          height = maxY - minY + 1;
366:          Rect letterRoi(minX, minY, width, height);
367:          componentsRoi_.push_back(letterRoi);
368:          label++;
369:          ccmap.at<float> (y, x) = -2;
370:  delete[] pStack;
371:  delete[] pVector;
372:  return label;
373:  int showCcmap = 0;
374:  Mat output = originalImage_.clone();
375:  assert(static_cast<size_t>(nComponent_) == componentsRoi_.size());
376:  isLetterComponects_ = new bool[nComponent_];
377:  vector<float> iComponentStrokeWidth;
378:  cout << nComponent_ << "componets" << endl;
379:  bool *innerComponents = new bool[nComponent_];
380:  for (size_t i = 0;
381:  for (size_t i = 0; i < nComponent_;
382:    float maxStrokeWidth = 0;
383:    float sumStrokeWidth = 0;
384:    float currentStrokeWidth;
385:    bool isLetter = true;
386:    Rect *itr = &componentsRoi_[i];
387:      isLetterComponects_[i] = false;
388:      continue;
389:    float maxY = itr->y + itr->height;
390:    float minY = itr->y;
391:    float maxX = itr->x + itr->width;
392:    float minX = itr->x;
393:    float increment = abs(itr->width - itr->height) / 2;
394:    memset(innerComponents, 0, nComponent_ * sizeof(bool));
395:      maxY = min(maxY + increment, static_cast<float> (ccmap.rows));
396:      minY = max(minY - increment, static_cast<float> (0.0));
397:      maxX = min(maxX + increment, static_cast<float> (ccmap.cols));
398:      minX = max(minX - increment, static_cast<float> (0.0));
399:    for (int y = minY;
400:    for (int y = minY; y < maxY;
401:      for (int x = minX;
402:      for (int x = minX; x < maxX;
403:        int component = static_cast<int> (ccmap.at<float> (y, x));
404:          currentStrokeWidth = swtmap.at<float> (y, x);
405:          iComponentStrokeWidth.push_back(currentStrokeWidth);
406:          maxStrokeWidth = max(maxStrokeWidth, currentStrokeWidth);
407:          sumStrokeWidth += currentStrokeWidth;
408:          innerComponents[component] = true;
409:    float pixelCount = static_cast<float> (iComponentStrokeWidth.size());
410:    float mean = sumStrokeWidth / pixelCount;
411:    float variance = 0;
412:    for (size_t ii = 0;
413:    for (size_t ii = 0; ii < pixelCount;
414:      variance += (iComponentStrokeWidth[ii] - mean, 2) * (iComponentStrokeWidth[ii] - mean, 2);
415:    variance = variance / pixelCount;
416:    isLetter = isLetter && (variance / mean < 1.5);
417:    isLetter = isLetter && (sqrt(((itr->width) * (itr->width) + (itr->height) * (itr->height))) / maxStrokeWidth < 10);
418:    isLetter = isLetter && (pixelCount / maxStrokeWidth > 5);
419:    isLetter = isLetter && (itr->width < 2.5 * itr->height);
420:      isLetter = false;
421:    isLetterComponects_[i] = isLetter;
422:    iComponentStrokeWidth.clear();
423:    for (size_t i = 0;
424:    for (size_t i = 0; i < nComponent_;
425:            + componentsRoi_[i].width, componentsRoi_[i].y + componentsRoi_[i].height), cvScalar((150), (110), (50)), 1);
426:        cv::imshow("identify bright letters=ccmap[after]", output);
427:        cv::imshow("identify dark letters=ccmap[after]", output);
428:    waitKey(0);
429:  delete[] innerComponents;
430:  int showGroupedLetters = 0;
431:  componentsMeanIntensity_ = new float[nComponent_];
432:  componentsMedianStrokeWidth_ = new float[nComponent_];
433:  isGrouped_ = new bool[nComponent_];
434:  memset(componentsMeanIntensity_, 0, nComponent_ * sizeof(float));
435:  memset(componentsMedianStrokeWidth_, 0, nComponent_ * sizeof(float));
436:  memset(isGrouped_, false, nComponent_ * sizeof(bool));
437:  Mat output = originalImage_.clone();
438:  for (size_t i = 0;
439:  for (size_t i = 0; i < nComponent_;
440:      continue;
441:    Rect iRect = componentsRoi_[i];
442:    float iMeanIntensity = getMeanIntensity(ccmap, iRect, static_cast<int> (i));
443:    float iMedianStrokeWidth = getMedianStrokeWidth(ccmap, swtmap, iRect, static_cast<int> (i));
444:    for (size_t j = i + 1;
445:    for (size_t j = i + 1; j < nComponent_;
446:        continue;
447:      Rect jRect = componentsRoi_[j];
448:      bool horizontal = (iRect.y < jRect.y + jRect.height && jRect.y < iRect.y + iRect.height);
449:      bool vertical = (iRect.x < jRect.x + jRect.width && jRect.x < iRect.x + iRect.width);
450:        continue;
451:          horizontal = true;
452:          vertical = false;
453:          horizontal = false;
454:          vertical = true;
455:          + iRect.height / 2 - jRect.y - jRect.height / 2));
456:      int distanceRatio = 4;
457:          continue;
458:          continue;
459:      float jMeanIntensity = getMeanIntensity(ccmap, jRect, static_cast<int> (j));
460:      float jMedianStrokeWidth = getMedianStrokeWidth(ccmap, swtmap, jRect, static_cast<int> (j));
461:      bool isGroup = true;
462:          < 2;
463:      isGroup = isGroup && (max(iRect.height, jRect.height) / min(iRect.height, jRect.height)) < 2;
464:      isGroup = isGroup && abs(iMeanIntensity - jMeanIntensity) < 10;
465:        isGrouped_[i] = true;
466:        isGrouped_[j] = true;
467:          horizontalLetterGroups_.push_back(Pair(i, j));
468:                    cvScalar(0, 0, 255), 2);
469:                    cvScalar(0, 0, 255), 2);
470:      cv::imshow("bright", output);
471:      cv::imshow("dark", output);
472:    waitKey(0);
473:  int showpairs = 0;
474:  int showchains = 0;
475:    Mat output = originalImage_.clone();
476:    for (int i = 0;
477:    for (int i = 0; i < horizontalLetterGroups_.size() - 1;
478:                          + componentsRoi_.at(horizontalLetterGroups_[i].left).height), cvScalar(255, 255, 255), 2);
479:                          + componentsRoi_.at(horizontalLetterGroups_[i].right).height), cvScalar(255, 255, 255), 2);
480:    cv::imshow("pairs", output);
481:    waitKey(0);
482:  mergePairs(horizontalLetterGroups_, horizontalChains_);
483:  vector<Rect> initialHorizontalBoxes;
484:  chainToBox(horizontalChains_, initialHorizontalBoxes);
485:    Mat output = originalImage_.clone();
486:    for (int i = 0;
487:    for (int i = 0; i < initialHorizontalBoxes.size();
488:                    + initialHorizontalBoxes[i].height), cvScalar(155, 55, 255), 2);
489:    cv::imshow("chains", output);
490:    waitKey(0);
491:  filterBoundingBoxes(initialHorizontalBoxes, ccmap, 4);
492:  boundingBoxes_.insert(boundingBoxes_.end(), initialHorizontalBoxes.begin(), initialHorizontalBoxes.end());
493:    Mat output = originalImage_.clone();
494:    for (int i = 0;
495:    for (int i = 0; i < boundingBoxes_.size();
496:          + boundingBoxes_[i].width, boundingBoxes_[i].y + boundingBoxes_[i].height), cvScalar(0, 55, 105), 2);
497:    cv::imshow("chains2", output);
498:    waitKey(0);
499:  int showHistogram = 1;
500:  int showRects = 0;
501:  int padding = 10;
502:  bgr whiteClr;
503:  whiteClr.r = 255;
504:  whiteClr.g = 255;
505:  whiteClr.b = 255;
506:  cv::Mat canvas;
507:  canvas.create(125, 360, CV_8UC3);
508:  int maxValue = 0, maxAngle = 0, angles = 360;
509:  int hist[angles], newHistogram[angles];
510:  double scale;
511:  for (unsigned int i = 0;
512:  for (unsigned int i = 0; i < boundingBoxes_.size();
513:      cv::Mat output = originalImage_.clone();
514:                    2);
515:      cv::imshow("right rectangles", output);
516:      cv::waitKey(0);
517:    maxValue = 0;
518:    maxAngle = 0;
519:    for (int y = 0;
520:    for (int y = 0; y < canvas.rows;
521:      for (int x = 0;
522:      for (int x = 0; x < canvas.cols;
523:        canvas.at<bgr> (y, x) = whiteClr;
524:    for (int j = 0;
525:    for (int j = 0; j < angles - 1;
526:      hist[j] = 0;
527:    for (int y = boundingBoxes_[i].y;
528:    for (int y = boundingBoxes_[i].y; y < boundingBoxes_[i].y + boundingBoxes_[i].height;
529:      for (int x = boundingBoxes_[i].x;
530:      for (int x = boundingBoxes_[i].x; x < boundingBoxes_[i].x + boundingBoxes_[i].width;
531:          int angle = (int)((180 / 3.141592) * theta_.at<float> (y, x)) + 180;
532:          hist[angle]++;
533:    double mask[3];
534:    mask[0] = 0.25;
535:    mask[1] = 0.5;
536:    mask[2] = 0.25;
537:    for (int bin = 1;
538:    for (int bin = 1; bin < 359;
539:      double smoothedValue = 0;
540:      for (int i = 0;
541:      for (int i = 0; i < 3;
542:        smoothedValue += hist[bin - 1 + i] * mask[i];
543:      newHistogram[bin] = smoothedValue;
544:    newHistogram[0] = hist[0] * (2 / 3) + hist[1] * (1 / 3);
545:    newHistogram[359] = hist[358] * (1 / 3) + hist[359] * (2 / 3);
546:    for (int bin = 1;
547:    for (int bin = 1; bin < 360;
548:      hist[bin] = newHistogram[bin];
549:    for (int j = 0;
550:    for (int j = 0; j < angles - 1;
551:      maxValue = hist[j] > maxValue ? hist[j] : maxValue;
552:    for (int j = 0;
553:    for (int j = 0; j < angles - 1;
554:        maxAngle = j;
555:    scale = maxValue > canvas.rows ? (double)canvas.rows / maxValue : 1.;
556:      for (int j = 0;
557:      for (int j = 0; j < angles - 1;
558:        cv::Point pt1(j, canvas.rows - (hist[j] * scale));
559:        cv::Point pt2(j, canvas.rows);
560:          cv::line(canvas, pt1, pt2, cv::Scalar(200, 160, 100), 2, 8, 0);
561:          cv::line(canvas, pt1, pt2, cv::Scalar(250, 210, 150), 1, 8, 0);
562:                  false);
563:                  false);
564:                  false);
565:                  false);
566:                  false);
567:      cv::imshow("Gradients", canvas);
568:      std::cout << "blackWhite:" << blackWhite << endl;
569:      std::cout << "maxAngle:" << maxAngle << "(" << maxAngle - 180 << ")" << endl;
570:    cv::Rect rectWithPadding;
571:    rectWithPadding.x = max(boundingBoxes_[i].x - padding, 0);
572:    rectWithPadding.y = max(boundingBoxes_[i].y - padding, 0);
573:        : rectWithPadding.height = boundingBoxes_[i].height + padding;
574:        : rectWithPadding.width = boundingBoxes_[i].width + padding;
575:    cv::Mat smallImg = image_(rectWithPadding);
576:    cv::Scalar averageColor = mean(smallImg);
577:    std::vector<int> bgColor;
578:    for (int y = 0;
579:    for (int y = 0; y < smallImg.rows;
580:      for (int x = 0;
581:      for (int x = 0; x < smallImg.cols;
582:            bgColor.push_back((unsigned int)smallImg.at<unsigned char> (y, x));
583:            bgColor.push_back((unsigned int)smallImg.at<unsigned char> (y, x));
584:    int average_bg = 0;
585:    for (int i = 0;
586:    for (int i = 0; i < bgColor.size();
587:      average_bg += bgColor[i];
588:    average_bg = average_bg / bgColor.size();
589:    cv::Point2f center;
590:    center.x = smallImg.cols * 0.5;
591:    center.y = smallImg.rows * 0.5;
592:    cv::Mat mapMatrix = cv::getRotationMatrix2D(center, maxAngle - 180, 1.0);
593:    cv::Mat rotatedImage;
594:    rotatedImage.create(smallImg.rows, smallImg.cols, CV_8UC1);
595:    for (int y = 0;
596:    for (int y = 0; y < rotatedImage.rows;
597:      for (int x = 0;
598:      for (int x = 0; x < rotatedImage.cols;
599:        rotatedImage.at<unsigned char> (y, x) = average_bg;
600:                   cv::Scalar(average_bg));
601:    cv::imshow("rotated", rotatedImage);
602:                                                     boundingBoxes_[i].height));
603:    rotated.push_back(*r);
604:  for (size_t i = 0;
605:  for (size_t i = 0; i < chain.size();
606:      continue;
607:    int minX = image_.cols, minY = image_.rows, maxX = 0, maxY = 0;
608:    int letterAreaSum = 0;
609:    int padding = 5;
610:    for (size_t j = 0;
611:    for (size_t j = 0; j < chain[i].size();
612:      Rect *itr = &componentsRoi_[chain[i][j]];
613:      letterAreaSum += itr->width * itr->height;
614:      minX = min(minX, itr->x);
615:      minY = min(minY, itr->y);
616:      maxX = max(maxX, itr->x + itr->width);
617:      maxY = max(maxY, itr->y + itr->height);
618:    minX = max(0, minX - padding);
619:    minY = max(0, minY - padding);
620:    maxX = min(image_.cols, maxX + padding);
621:    maxY = min(image_.rows, maxY + padding);
622:    boundingBox.push_back(Rect(minX, minY, maxX - minX, maxY - minY));
623:  return a.y < b.y;
624:  vector<Rect> qualifiedBoxes;
625:  vector<int> components;
626:  for (size_t i = 0;
627:  for (size_t i = 0; i < boundingBoxes.size();
628:    int isLetterCount = 0;
629:    int letterArea = 0;
630:    int nonLetterArea = 0;
631:    Rect *rect = &boundingBoxes[i];
632:    float width = static_cast<float> (rect->width);
633:    float height = static_cast<float> (rect->height);
634:      continue;
635:      continue;
636:    for (int y = rect->y;
637:    for (int y = rect->y; y < rect->y + rect->height;
638:      for (int x = rect->x;
639:      for (int x = rect->x; x < rect->x + rect->width;
640:        int componetIndex = static_cast<int> (ccmap.at<float> (y, x));
641:          continue;
642:          letterArea++;
643:          nonLetterArea++;
644:          components.push_back(componetIndex);
645:            isLetterCount++;
646:      qualifiedBoxes.push_back(*rect);
647:    components.clear();
648:  boundingBoxes = qualifiedBoxes;
649:  vector<Rect> bigBoxes;
650:  Mat tempMap(image_.size(), CV_32FC1, Scalar(0));
651:  for (size_t i = 0;
652:  for (size_t i = 0; i < boundingBoxes.size();
653:    Rect *rect = &boundingBoxes[i];
654:    for (int y = rect->y;
655:    for (int y = rect->y; y < rect->y + rect->height;
656:      for (int x = rect->x;
657:      for (int x = rect->x; x < rect->x + rect->width;
658:        tempMap.at<float> (y, x) = 50;
659:  for (size_t i = 0;
660:  for (size_t i = 0; i < boundingBoxes.size();
661:      continue;
662:    Rect rect;
663:    floodFill(tempMap, Point(boundingBoxes[i].x, boundingBoxes[i].y), i + 100, &rect);
664:    int padding = 5;
665:    int minX = max(0, rect.x - padding);
666:    int minY = max(0, rect.y - padding);
667:    int maxX = min(image_.cols, rect.x + rect.width + padding);
668:    int maxY = min(image_.rows, rect.y + rect.height + padding);
669:    bigBoxes.push_back(Rect(minX, minY, maxX - minX, maxY - minY));
670:  boundingBoxes = bigBoxes;
671:  cout << endl;
672:  cout << "888" << endl;
673:  assert(box.size() == text.size());
674:  Scalar color(0, 255, 0);
675:  size_t lineWidth = 25;
676:  int indent = 50;
677:  int count = 1;
678:  for (size_t i = 0;
679:  for (size_t i = 0; i < box.size();
680:      indent = 70;
681:    string output = text[i];
682:      continue;
683:    std::string s;
684:    std::stringstream out;
685:    out << count;
686:    count++;
687:    string prefix = "[";
688:    prefix = prefix + out.str() + "]";
689:            color, 2);
690:    putText(detection_, prefix, Point(image_.cols, textDisplayOffset_ * 35), FONT_HERSHEY_DUPLEX, 1, color, 2);
691:              FONT_HERSHEY_DUPLEX, 1, color, 2);
692:      output = output.substr(lineWidth);
693:      textDisplayOffset_++;
694:    putText(detection_, output, Point(image_.cols + indent, textDisplayOffset_ * 35), FONT_HERSHEY_DUPLEX, 1, color, 2);
695:    textDisplayOffset_ += 2;
696:  sort(boundingBoxes.begin(), boundingBoxes.end(), DetectText::spaticalOrder);
697:  for (size_t i = 0;
698:  for (size_t i = 0; i < boundingBoxes.size();
699:    string result;
700:    float score = ocrRead(originalImage_(boundingBoxes[i]), result, -1);
701:      boxesBothSides_.push_back(boundingBoxes[i]);
702:      wordsBothSides_.push_back(result);
703:      boxesScores_.push_back(score);
704:  float score = 0;
705:  Mat scaledImage;
706:    double scale = 1.5;
707:    resize(imagePatch, scaledImage, Size(0, 0), scale, scale, INTER_LANCZOS4);
708:    imwrite("patch.tiff", scaledImage);
709:    imwrite("patch.tiff", imagePatch);
710:  system("$(cp patch.tiff ~)");
711:  int result;
712:  result = system("$(rospack find cob_tesseract)/bin/tesseract patch.tiff patch");
713:  cout << "result" << result << endl;
714:  assert(!result);
715:  ifstream fin("patch.txt");
716:  string str;
717:    cout << "in ocrRead:" << endl;
718:    cout << "[" << str << "]" << endl;
719:    string tempOutput;
720:    score += spellCheck(str, tempOutput, 2);
721:    output += tempOutput;
722:  result = system("$(rm patch.txt patch.tiff)");
723:  return score;
724:  int letterCount = 0, errorCount = 0, lNoiseCount = 0, digitCount = 0;
725:  string withoutStrangeMarks;
726:  float score = 0;
727:  str = trim(str);
728:  cout << "in spellCheck" << endl;
729:  for (size_t i = 0;
730:  for (size_t i = 0; i < str.length();
731:      withoutStrangeMarks += str[i];
732:      letterCount++;
733:        lNoiseCount++;
734:      digitCount++;
735:        withoutStrangeMarks += '1';
736:        str[i] = '1';
737:        digitCount++;
738:        withoutStrangeMarks += 'l';
739:        errorCount++;
740:        letterCount++;
741:      withoutStrangeMarks += 'L';
742:      errorCount++;
743:      letterCount++;
744:      withoutStrangeMarks += 'I';
745:      errorCount++;
746:      letterCount++;
747:      str[i] = ' ';
748:      output = str + " ";
749:      output = str + " ";
750:      const string command("echo " + withoutStrangeMarks + " | aspell -a >> output");
751:      int r = system(command.c_str());
752:      fstream fin("output");
753:      string result;
754:      int count = 0;
755:          count++;
756:            output += result + " ";
757:              ((output)[output.length() - 2] = ' ');
758:            break;
759:          count++;
760:          output += "{";
761:          output += " " + str;
762:          break;
763:        output += "}";
764:      r = system("rm output");
765:      cout << "METHOD==2" << endl;
766:      vector<Word> topk;
767:      string nearestWord;
768:      getTopkWords(withoutStrangeMarks, 3, topk);
769:        string topWord = topk[0].word;
770:        output = topk[0].word + " ";
771:            score++;
772:            output = "";
773:            score++;
774:            output = "";
775:            score = topWord.length() * 2;
776:            score = topWord.length();
777:          output = topk[0].word + " ";
778:          score += topk[0].word.length() * 2;
779:          output = "{" + withoutStrangeMarks + "->";
780:          for (int i = 0;
781:          for (int i = 0; i < 3;
782:            stringstream ss;
783:            ss << topk[i].score;
784:            string s = ss.str();
785:            output = output + topk[i].word + ":" + s + " ";
786:          output += "} ";
787:  return score;
788:  Mat result;
789:  Mat element = getStructuringElement(MORPH_ELLIPSE, Size(patch.cols / 3, patch.rows / 3));
790:  morphologyEx(patch, result, MORPH_TOPHAT, element);
791:  return result;
792:  delete[] isLetterComponects_;
793:  delete[] isGrouped_;
794:  delete[] componentsMeanIntensity_;
795:  delete[] componentsMedianStrokeWidth_;
796:  componentsRoi_.clear();
797:  innerComponents_.clear();
798:  horizontalLetterGroups_.clear();
799:  verticalLetterGroups_.clear();
800:  horizontalChains_.clear();
801:  verticalChains_.clear();
802:  std::cout << std::endl;
803:  std::cout << "Correlation:" << file << std::endl;
804:  ifstream fin(file);
805:  correlation_ = Mat(62, 62, CV_32F, Scalar(0));
806:  float number;
807:  for (int i = 0;
808:  for (int i = 0; i < 62;
809:    for (int j = 0;
810:    for (int j = 0; j < 62;
811:      assert(fin >> number);
812:      correlation_.at<float> (i, j) = number;
813:  ifstream fin(filename);
814:  string word;
815:  wordList_.clear();
816:    wordList_.push_back(word);
817:  assert(wordList_.size());
818:  cout << "read in " << wordList_.size() << " words from " << string(filename) << endl;
819:  size_t startpos = str.find_first_not_of(" \t");
820:  size_t endpos = str.find_last_not_of(" \t");
821:    str = "";
822:    str = str.substr(startpos, endpos - startpos + 1);
823:  return str;
824:  cout << "start searching match for " << str << endl;
825:  float score, lowestScore = 100;
826:  int referenceScore;
827:  size_t index = 0;
828:  for (size_t i = 0;
829:  for (size_t i = 0; i < wordList_.size();
830:    cout << "matching...." << wordList_[i];
831:    score = editDistanceFont(str, wordList_[i]);
832:    referenceScore = editDistance(str, wordList_[i]);
833:    cout << " " << score << " " << referenceScore << endl;
834:      lowestScore = score;
835:      cout << "AHA! better!" << endl;
836:      index = i;
837:  nearestWord = wordList_[index];
838:  cout << nearestWord << " got the lowest score: " << lowestScore << endl;
839:  float score, lowestScore = 100;
840:  words.clear();
841:  words.resize(k);
842:  cout << "in getTopkWords with [" << str << "]" << endl;
843:  for (size_t i = 0;
844:  for (size_t i = 0; i < wordList_.size();
845:    score = editDistanceFont(str, wordList_[i]);
846:      Word w = Word(wordList_[i], score);
847:      lowestScore = insertToList(words, w);
848:  cout << "lowestScore:" << lowestScore << endl;
849:  size_t index = 0;
850:  for (size_t i = 0;
851:  for (size_t i = 0; i < words.size();
852:    index = i;
853:      break;
854:    for (size_t i = words.size() - 1;
855:    for (size_t i = words.size() - 1; i > index;
856:      words[i] = words[i - 1];
857:    words[index] = word;
858:  return words[words.size() - 1].score;
859:    imwrite("edgemap.png", edgemap_);
860:  Mat ccmapLetters = ccmap * (1.0 / static_cast<float> (nComponent_));
861:  for (size_t i = 0;
862:  for (size_t i = 0; i < nComponent_;
863:    Rect *itr = &componentsRoi_[i];
864:    rectangle(ccmapLetters, Point(itr->x, itr->y), Point(itr->x + itr->width, itr->y + itr->height), Scalar(0.5));
865:    imwrite("ccmap1.jpg", ccmapLetters * nComponent_);
866:    imwrite("ccmap2.jpg", ccmapLetters * nComponent_);
867:    imwrite("swtmap1.jpg", swtmap * 10);
868:    imwrite("swtmap2.jpg", swtmap * 10);
869:  Mat output = originalImage_.clone();
870:  Scalar scalar;
871:    scalar = Scalar(0, 255, 0);
872:    scalar = Scalar(0, 0, 255);
873:  for (size_t i = 0;
874:  for (size_t i = 0; i < nComponent_;
875:      Rect *itr = &componentsRoi_[i];
876:      rectangle(output, Point(itr->x, itr->y), Point(itr->x + itr->width, itr->y + itr->height), scalar, 2);
877:      stringstream ss;
878:      string s;
879:      ss << i;
880:      s = ss.str() + ".tiff";
881:      imwrite(s, originalImage_(*itr));
882:    imwrite(outputPrefix_ + "_letters1.jpg", output);
883:    imwrite(outputPrefix_ + "_letters2.jpg", output);
884:  Mat output = originalImage_.clone();
885:  Scalar scalar;
886:    scalar = Scalar(0, 255, 0);
887:    scalar = Scalar(0, 0, 255);
888:  for (size_t i = 0;
889:  for (size_t i = 0; i < nComponent_;
890:      Rect *itr = &componentsRoi_[i];
891:      rectangle(output, Point(itr->x, itr->y), Point(itr->x + itr->width, itr->y + itr->height), scalar, 2);
892:    imwrite(outputPrefix_ + "_group1.jpg", output);
893:    imwrite(outputPrefix_ + "_group2.jpg", output);
894:  Scalar scalar(0, 0, 255);
895:  for (size_t i = 0;
896:  for (size_t i = 0; i < boundingBoxes.size();
897:    Rect *rect = &boundingBoxes[i];
898:    rectangle(detection_, Point(rect->x, rect->y), Point(rect->x + rect->width, rect->y + rect->height), scalar, 3);
899:  assert(boundingBoxes.size() == boxInbox.size());
900:  Scalar scalar;
901:  scalar = Scalar(0, 0, 255);
902:  for (size_t i = 0;
903:  for (size_t i = 0; i < boundingBoxes.size();
904:      continue;
905:    Rect *rect = &boundingBoxes[i];
906:    rectangle(detection_, Point(rect->x, rect->y), Point(rect->x + rect->width, rect->y + rect->height), scalar, 3);
907:  int count = 0;
908:  for (size_t i = 0;
909:  for (size_t i = 0; i < nComponent_;
910:      count++;
911:  return count;
912:  assert(element >= 0);
913:    float sum = 0;
914:    float count = 0;
915:    float felement = static_cast<float> (element);
916:    for (int y = rect.y;
917:    for (int y = rect.y; y < rect.y + rect.height;
918:      for (int x = rect.x;
919:      for (int x = rect.x; x < rect.x + rect.width;
920:          sum += static_cast<float> (image_.at<unsigned char> (y, x));
921:          count = count + 1;
922:    componentsMeanIntensity_[element] = sum / count;
923:  return componentsMeanIntensity_[element];
924:  assert(element >= 0);
925:  assert(isLetterComponects_[element]);
926:    vector<float> SwtValues;
927:    float felement = static_cast<float> (element);
928:    for (int y = rect.y;
929:    for (int y = rect.y; y < rect.y + rect.height;
930:      for (int x = rect.x;
931:      for (int x = rect.x; x < rect.x + rect.width;
932:          SwtValues.push_back(swtmap.at<float> (y, x));
933:    nth_element(SwtValues.begin(), SwtValues.begin() + SwtValues.size() / 2, SwtValues.end());
934:    componentsMedianStrokeWidth_[element] = SwtValues[SwtValues.size() / 2];
935:  return componentsMedianStrokeWidth_[element];
936:  vector<vector<int> > initialChains;
937:  initialChains.resize(groups.size());
938:  for (size_t i = 0;
939:  for (size_t i = 0; i < groups.size();
940:    vector<int> temp;
941:    temp.push_back(groups[i].left);
942:    temp.push_back(groups[i].right);
943:    initialChains[i] = temp;
944:    initialChains = chains;
945:    chains.clear();
946:    chains.clear();
947:  bool merged = false;
948:  int *mergedToChainBitMap = new int[initialChains.size()];
949:  memset(mergedToChainBitMap, -1, initialChains.size() * sizeof(int));
950:  for (size_t i = 0;
951:  for (size_t i = 0; i < initialChains.size();
952:      continue;
953:    for (size_t j = i + 1;
954:    for (size_t j = i + 1; j < initialChains.size();
955:      for (size_t ki = 0;
956:      for (size_t ki = 0; ki < initialChains[i].size();
957:        for (size_t kj = 0;
958:        for (size_t kj = 0; kj < initialChains[j].size();
959:            merged = true;
960:              merge(initialChains[i], chains[mergedToChainBitMap[j]]);
961:              mergedToChainBitMap[i] = mergedToChainBitMap[j];
962:              vector<int> newChain;
963:              merge(initialChains[i], newChain);
964:              merge(initialChains[j], newChain);
965:              chains.push_back(newChain);
966:              mergedToChainBitMap[i] = chains.size() - 1;
967:              mergedToChainBitMap[j] = chains.size() - 1;
968:            break;
969:          break;
970:      chains.push_back(initialChains[i]);
971:      mergedToChainBitMap[i] = chains.size() - 1;
972:    chains = initialChains;
973:  delete[] mergedToChainBitMap;
974:  return merged;
975:  vector<int>::iterator it;
976:  for (size_t i = 0;
977:  for (size_t i = 0; i < token.size();
978:    it = find(chain.begin(), chain.end(), token[i]);
979:      chain.push_back(token[i]);
980:  float penalty = 0.7;
981:  int n = s.length();
982:  int m = t.length();
983:    return m;
984:    return n;
985:  float **d = new float*[n + 1];
986:  for (int i = 0;
987:  for (int i = 0; i < n + 1;
988:    d[i] = new float[m + 1];
989:    memset(d[i], 0, (m + 1) * sizeof(float));
990:  for (int i = 0;
991:  for (int i = 0; i < n + 1;
992:    d[i][0] = i;
993:  for (int j = 0;
994:  for (int j = 0; j < m + 1;
995:    d[0][j] = j;
996:  for (int i = 1;
997:  for (int i = 1; i < n + 1;
998:    char sc = s[i - 1];
999:    for (int j = 1;
1000:    for (int j = 1; j < m + 1;
1001:      float v = d[i - 1][j - 1];
1002:        int a = getCorrelationIndex(t[j - 1]);
1003:        int b = getCorrelationIndex(sc);
1004:          cout << "Wort:" << t << endl;
1005:        float correlate = correlation_.at<float> (a, b);
1006:        v = v + 1 - correlate;
1007:      d[i][j] = min(min(d[i - 1][j] + penalty, d[i][j - 1] + penalty), v);
1008:  float result = d[n][m];
1009:  for (int i = 0;
1010:  for (int i = 0; i < n + 1;
1011:    delete[] d[i];
1012:  delete[] d;
1013:  return result;
1014:    return letter - 'a';
1015:    return letter - 'A' + 26;
1016:    return letter - '0' + 52;
1017:  cout << "illigal letter: " << letter << endl;
1018:  return -1;
1019:  int n = s.length();
1020:  int m = t.length();
1021:    return m;
1022:    return n;
1023:  int **d = new int*[n + 1];
1024:  for (int i = 0;
1025:  for (int i = 0; i < n + 1;
1026:    d[i] = new int[m + 1];
1027:    memset(d[i], 0, (m + 1) * sizeof(int));
1028:  for (int i = 0;
1029:  for (int i = 0; i < n + 1;
1030:    d[i][0] = i;
1031:  for (int j = 0;
1032:  for (int j = 0; j < m + 1;
1033:    d[0][j] = j;
1034:  for (int i = 1;
1035:  for (int i = 1; i < n + 1;
1036:    char sc = s[i - 1];
1037:    for (int j = 1;
1038:    for (int j = 1; j < m + 1;
1039:      int v = d[i - 1][j - 1];
1040:        v++;
1041:      d[i][j] = min(min(d[i - 1][j] + 1, d[i][j - 1] + 1), v);
1042:  return d[n][m];
1043:  assert(getCorrelationIndex('a') == 0);
1044:  assert(getCorrelationIndex('c') == 2);
1045:  assert(getCorrelationIndex('A') == 26);
1046:  assert(getCorrelationIndex('0') == 52);
1047:  assert(getCorrelationIndex('9') == 61);
1048:  cout << "pass getCorrelationIndex test" << endl;
1049:  string a("hello");
1050:  string b("helo");
1051:  assert(editDistance(a,b)==1);
1052:  string c("hello");
1053:  string d("xello");
1054:  cout << "distance betweeen " << c << " & " << d << ": " << editDistance(c, d) << endl;
1055:  cout << "distance with font betweeen " << c << " & " << d << ":" << editDistanceFont(c, d) << endl;
1056:  vector<Word> list;
1057:  list.resize(10);
1058:  for (int i = 0;
1059:  for (int i = 0; i < 10;
1060:    float score = rand() % 50;
1061:    Word w = Word("", score);
1062:    insertToList(list, w);
1063:    for (size_t i = 0;
1064:    for (size_t i = 0; i < 10;
1065:      cout << list[i].score << " <= ";
1066:    cout << endl;
1067:  int a[] = {1, 2, 3};
1068:  int b[] = {2, 3, 9};
1069:  int c[] = {7, 5};
1070:  int d[] = {2, 4, 6};
1071:  vector<vector<int> > initialChain;
1072:  vector<vector<int> > outputChain;
1073:  vector<int> va(a, a + 3);
1074:  vector<int> vb(b, b + 3);
1075:  vector<int> vc(c, c + 2);
1076:  vector<int> vd(d, d + 3);
1077:  initialChain.push_back(va);
1078:  initialChain.push_back(vb);
1079:  initialChain.push_back(vc);
1080:  initialChain.push_back(vd);
1081:    initialChain = outputChain;
1082:    outputChain.clear();
1083:  for (size_t i = 0;
1084:  for (size_t i = 0; i < outputChain.size();
1085:    for (size_t j = 0;
1086:    for (size_t j = 0; j < outputChain[i].size();
1087:      cout << outputChain[i][j] << " ";
1088:    cout << endl;
1089:  Mat temp(edgemap_.size(), CV_8UC1);
1090:  vector<Point>::iterator itr = edgepoints.begin();
1091:  for (;
1092:  for (; itr != edgepoints.end();
1093:    temp.at<unsigned char> (*itr) = 255;
1094:  imshow("test edge", temp);
1095:  waitKey();
1096:namespace enc = sensor_msgs::image_encodings;
1097:static const char WINDOW[] = "Image window";
1098:<font color="#FF0000">  ros::NodeHandle nh_;</font>{}
1099:  image_transport::ImageTransport it_;
1100:<font color="#FF0000">  image_transport::Subscriber image_sub_;</font>{}
1101:<font color="#FF0000">  image_transport::Publisher image_pub_;</font>{}
1102:<font color="#FF0000">  ros::Subscriber robot_state_sub_;</font>{}
1103:<font color="#FF0000">  ros::Subscriber depth_sub_;</font>{}
1104:  DetectText detector;
1105:  ros::Time last_movement_;
1106:  pthread_mutex_t pr2_velocity_lock_;
1107:  pthread_mutex_t pr2_image_lock_;
1108:  cv_bridge::CvImagePtr cv_ptr;
1109:  cv_bridge::CvImagePtr detection_ptr;
1110:  float x_;
1111:  float y_;
1112:  bool okToDetect_;
1113:  bool initialized_;
1114:<font color="#FF0000">    image_pub_ = it_.advertise("text_detect", 1);</font>{}
1115:<font color="#FF0000">    image_sub_ = it_.subscribe("image_color", 1, &TextReader::imageCb, this);</font>{}
1116:<font color="#FF0000">    robot_state_sub_ = nh_.subscribe("/base_odometry/state", 1, &TextReader::robotStateCb, this);</font>{}
1117:    detector = DetectText();
1118:    detector.readLetterCorrelation(correlation);
1119:    detector.readWordList(dictionary);
1120:    pthread_mutex_init(&pr2_velocity_lock_, NULL);
1121:    pthread_mutex_init(&pr2_image_lock_, NULL);
1122:    okToDetect_ = false;
1123:    initialized_ = false;
1124:    x_ = 0;
1125:    y_ = 0;
1126:    pthread_mutex_trylock(&pr2_velocity_lock_);
1127:    x_ = msg->velocity.linear.x;
1128:    y_ = msg->velocity.linear.y;
1129:      last_movement_ = ros::Time::now();
1130:    pthread_mutex_unlock(&pr2_velocity_lock_);
1131:      pthread_mutex_trylock(&pr2_image_lock_);
1132:      cv_ptr = cv_bridge::toCvCopy(msg, enc::BGR8);
1133:        detection_ptr = cv_bridge::toCvCopy(msg, enc::BGR8);
1134:        initialized_ = true;
1135:      okToDetect_ = true;
1136:      pthread_mutex_unlock(&pr2_image_lock_);
1137:      ROS_ERROR("cv_bridge exception: %s", e.what());
1138:      okToDetect_ = false;
1139:      return;
1140:};
1141:    ROS_ERROR( "not enought input: read_text <correlation> <dictionary>");
1142:    return 1;
1143:<font color="#FF0000">  ros::init(argc, argv, "cob_read_text");</font>{}
1144:  TextReader reader(argv[1], argv[2]);
1145:  DetectText &detector = reader.detector;
1146:  ros::Rate r(1);
1147:  ros::Time last_detection = ros::Time::now();
1148:      ROS_INFO("start detection........");
1149:      ros::Time now = ros::Time::now();
1150:        ROS_INFO("waiting...");
1151:<font color="#FF0000">        ros::spinOnce();</font>{}
1152:        r.sleep();
1153:        continue;
1154:      pthread_mutex_lock(&(reader.pr2_velocity_lock_));
1155:      bool is_steady = (now - reader.last_movement_ > ros::Duration(2));
1156:      bool is_moving = (reader.x_ != 0 || reader.y_ != 0);
1157:      pthread_mutex_unlock(&(reader.pr2_velocity_lock_));
1158:<font color="#FF0000">        ros::spinOnce();</font>{}
1159:        r.sleep();
1160:        continue;
1161:      pthread_mutex_lock(&(reader.pr2_image_lock_));
1162:      detector.detect(reader.cv_ptr->image);
1163:      pthread_mutex_unlock(&(reader.pr2_image_lock_));
1164:      reader.detection_ptr->image = detector.getDetection();
1165:<font color="#FF0000">      reader.image_pub_.publish(reader.detection_ptr->toImageMsg());</font>{}
1166:    std::cout << "----------------------------------" << endl;
1167:    std::cout << "Texts found: " << detector.getWords().size() << endl;
1168:    for (int i = 0;
1169:    for (int i = 0; i < detector.getWords().size();
1170:          << ",width=" << ((detector.getBoxesBothSides())[0]).width << endl;
1171:    std::cout << "----------------------------------" << endl;
1172:    last_detection = ros::Time::now();
1173:<font color="#FF0000">    ros::spinOnce();</font>{}
1174:    r.sleep();
1175:  return 0;
</pre>
</body>
</html>
