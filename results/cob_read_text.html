<html>
<body>
    <table summary="code examples">
 
        <tr>

        <td><pre style="border: 1px solid #888;padding: 2px">
    count++;
    rects.push_back(r);
    texts.push_back(t);
  std::string img_name;
  std::vector<cv::Rect> rects;
  std::vector<std::string> texts;
  static int count;
};
int img::count = 0;
    return atoi((output.substr(output.find(label) + label.length() + 1, output.length() - 2 - label.length())).c_str());
    return -1;
  for (int i = 0;
  for (int i = 0; i < images.size();
    img * im = new img(images[i].img_name);
    ocrImages.push_back(*im);
    std::string imgpath = path.substr(0, path.find_last_of("/") + 1);
    imgpath.append(images[i].img_name);
        + " $(rospack find read_text)/fonts/correlation.txt $(rospack find read_text)/dictionary/full-dictionary";
    std::ifstream ocrfile;
    std::string textname = images[i].img_name.substr(0, images[i].img_name.find_last_of(".")) + ".txt";
    ocrfile.open(textname.c_str());
      std::cout << "While opening read_text results file an error is encountered" << std::endl;
      return -1;
    std::string input;
      for (int a = 0;
      for (int a = 0; !ocrfile.eof();
        ocrfile >> input;
        static int x, y, width, height;
          x = atoi(input.c_str());
          y = atoi(input.c_str());
          width = atoi(input.c_str());
          height = atoi(input.c_str());
          cv::Rect * r = new cv::Rect(x, y, width, height);
          ocrImages[img::count - 1].setRect(*r);
      ocrfile.close();
    textname = images[i].img_name.substr(0, images[i].img_name.find_last_of(".")) + "t.txt";
    ocrfile.open(textname.c_str());
      std::cout << "While opening read_text results file an error is encountered" << std::endl;
      return -1;
      std::string s;
        ocrImages[img::count - 1].setText(s);
  return 0;
  std::string label[] = {"<imageName>", "x=", "y=", "width=", "height=", "text="};
  std::ifstream imgxml;
  imgxml.open(filename.c_str());
      std::string filename;
      int x, y, width, height;
      std::string text;
      std::string output;
      imgxml >> output;
            = output.substr(output.find(label[0]) + label[0].length(), output.length() - 2 * label[0].length() - 1);
        img * i = new img(filename);
        images.push_back(*i);
        x = cutout(label[1], output);
        y = cutout(label[2], output);
        width = cutout(label[3], output);
        height = cutout(label[4], output);
        text = output.substr(output.find(label[5]) + label[5].length() + 1, output.length() - label[5].length() - 2);
        cv::Rect * r = new cv::Rect(x, y, width, height);
        images[img::count - 1].setRect(*r);
        images[img::count - 1].setText(text);
    imgxml.close();
  std::vector<cv::Rect>::iterator it;
  for (int h = 0;
  for (int h = 0; h < ocrImages.size();
    for (int i = 0;
    for (int i = 0; i < ocrImages[h].rects.size();
      for (int j = i + 1;
      for (int j = i + 1; j < ocrImages[h].rects.size();
          it = find(ocrImages[h].rects.begin(), ocrImages[h].rects.end(), ocrImages[h].rects[j]);
          ocrImages[h].rects.erase(it);
  for (int h = 0;
  for (int h = 0; h < ocrImages.size();
    std::string imgpath = path.substr(0, path.find_last_of("/") + 1);
    imgpath.append(ocrImages[h].img_name);
    cv::Mat OriginalImage_ = cv::imread(imgpath);
    cv::Mat Image_(OriginalImage_.rows, OriginalImage_.cols + 600, OriginalImage_.type());
    Image_.setTo(cv::Scalar(0, 0, 0, 0));
    cv::Mat roi = cv::Mat(Image_, cv::Rect(cv::Point(0, 0), OriginalImage_.size()));
    OriginalImage_.copyTo(roi);
                cv::FONT_HERSHEY_SIMPLEX, 0.75, cv::Scalar(255, 0, 0, 0), 1.5, 8, false);
                cv::Scalar(0, 255, 0, 0), 1.5, 8, false);
                cv::Scalar(0, 0, 255, 0), 1.5, 8, false);
             cv::Scalar(50, 50, 50, 0), 1, 1, 0);
    for (int i = 0;
    for (int i = 0; i < ocrImages[h].rects.size();
                        + ocrImages[h].rects[i].height), cvScalar((255 - 10 * i), (0), (0)), 2);
      std::string output;
      std::stringstream out;
          << ocrImages[h].rects[i].width << " | " << ocrImages[h].rects[i].height << " ]";
      output = out.str();
                  cv::FONT_HERSHEY_SIMPLEX, 0.5, cv::Scalar((255 - 10 * i), 0, 0, 0), 1.5, 8, false);
    for (int i = 0;
    for (int i = 0; i < images[h].rects.size();
                                                                                                  (0)), 2);
      std::string output;
      std::stringstream out;
          << " | " << images[h].rects[i].height << " ]";
      output = out.str();
                  cv::Scalar(0, (255 - 50 * i), 0, 0), 1.5, 8, false);
    cv::imshow(ocrImages[h].img_name, Image_);
    cv::waitKey(0);
  for (int i = 0;
  for (int i = 0; i < images.size();
    std::cout << images[i].img_name << ":" << std::endl;
    for (int j = 0;
    for (int j = 0; j < images[i].rects.size();
          << images[i].rects[j].height << " [" << images[i].texts[j] << "]" << std::endl;
  for (int i = 0;
  for (int i = 0; i < images.size();
    std::cout << ocrImages[i].img_name << ":" << std::endl;
    for (int j = 0;
    for (int j = 0; j < ocrImages[i].rects.size();
          << "|" << ocrImages[i].rects[j].height << " [" << ocrImages[i].texts[j] << "]" << std::endl;
  for (int i = 0;
  for (int i = 0; i < ocrImages.size();
    int retrieved = (int)ocrImages[i].rects.size();
    int relevant = (int)images[i].rects.size();
    for (int j = 0;
    for (int j = 0; j < ocrImages[i].rects.size();
      for (int k = 0;
      for (int k = 0; k < images[i].rects.size();
          int intersectionPixels = (ocrImages[i].rects[j] & images[i].rects[k]).area();
          unsigned int percent = (intersectionPixels / (images[i].rects[k].area())) * 100;
                * 100;
          std::string output;
          std::stringstream out;
          out << "overlap: correct[" << i << "] & found[" << j << "]: " << percent << "%";
    ROS_ERROR( "not enought input: eval_read_text <img_list.xml>");
    return 1;
  std::vector<img> images;
  std::vector<img> ocrImages;
  readInSolution(images, argv[1]);
  img::count = 0;
  readInEstimates(images, ocrImages, argv[1]);
  calculateResults(images, ocrImages);
  showRects(images, ocrImages, argv[1]);
  return 0;
		<< endl;
		return -1;
	DetectText detector = DetectText();
	detector.readLetterCorrelation(argv[2]);
	detector.readWordList(argv[3]);
	detector.detect(string(argv[1]));
	return 0;
using namespace cv;
using namespace std;
  filename_ = filename;
  originalImage_ = imread(filename_);
    ROS_ERROR("Cannot read image input...");
    return;
  mode_ = IMAGE;
  detect();
  filename_ = string("streaming.jpg");
  originalImage_ = image;
  mode_ = STREAM;
  detect();
  double start_time;
  double time_in_seconds;
  start_time = clock();
  Mat imGray(originalImage_.size(), CV_8UC1, Scalar(0));
  cvtColor(originalImage_, imGray, CV_RGB2GRAY);
  boundingBoxes_.clear();
  boxesBothSides_.clear();
  wordsBothSides_.clear();
  boxesScores_.clear();
  preprocess(imGray);
  firstPass_ = true;
  pipeline(1);
  cout << "Second pass" << endl;
  firstPass_ = false;
  pipeline(-1);
  overlapBoundingBoxes(boundingBoxes_);
  ocrRead(boundingBoxes_);
  showBoundingBoxes(boxesBothSides_);
  std::cout << "1\n";
  overlayText(boxesBothSides_, wordsBothSides_);
  std::cout << "1\n";
    ofstream myfile, myfile2;
    std::string textname = outputPrefix_ + ".txt";
    std::string textname2 = outputPrefix_ + "t.txt";
    myfile.open(textname.c_str());
    for (int i = 0;
    for (int i = 0; i < boxesBothSides_.size();
          << boxesBothSides_[i].height << "\n";
    myfile.close();
    myfile2.open(textname2.c_str());
    for (int i = 0;
    for (int i = 0; i < wordsBothSides_.size();
      myfile2 << wordsBothSides_[i] << "\n";
    myfile2.close();
  imwrite(outputPrefix_ + "_detection.jpg", detection_);
  time_in_seconds = (clock() - start_time) / (double)CLOCKS_PER_SEC;
  cout << time_in_seconds << "s total in process\n" << endl;
  textDisplayOffset_ = 1;
  int maxStrokeWidthParameter = 50;
  maxLetterHeight_ = 300;
  minLetterHeight_ = 5;
  cout << "preprocessing: " << filename_ << endl;
  cout << "image size:" << image.cols << "X" << image.rows << endl;
  int slashIndex = -1;
  int dotIndex = -1;
  for (size_t i = filename_.length() - 1;
  for (size_t i = filename_.length() - 1; i != 0;
      dotIndex = i;
      slashIndex = i;
  outputPrefix_ = filename_.substr(slashIndex + 1, dotIndex - slashIndex - 1);
  cout << "outputPrefix: " << outputPrefix_ << endl;
  image_ = image;
  maxStrokeWidth_ = round((float)(max(image.cols, image.rows)) / maxStrokeWidthParameter);
  initialStrokeWidth_ = maxStrokeWidth_ * 2;
  IplImage *img2 = new IplImage(originalImage_);
  IplImage *img1 = cvCreateImage(cvSize(image.cols + 600, image.rows), img2->depth, img2->nChannels);
  cvSet(img1, cvScalar(0, 0, 0));
  cvSetImageROI(img1, cvRect(0, 0, image.cols, image.rows));
  cvCopy(img2, img1, NULL);
  cvResetImageROI(img1);
  detection_ = Mat(img1).clone();
  cvReleaseImage(&img1);
  delete img1;
  delete img2;
  return detection_;
  return wordsBothSides_;
  return boxesBothSides_;
    fontColor_ = BRIGHT;
    fontColor_ = DARK;
    cout << "blackwhite should only be +/-1" << endl;
    assert(false);
  double start_time;
  double time_in_seconds;
  start_time = clock();
  Mat swtmap(image_.size(), CV_32FC1, Scalar(initialStrokeWidth_));
  strokeWidthTransform(image_, swtmap, blackWhite);
  time_in_seconds = (clock() - start_time) / (double)CLOCKS_PER_SEC;
  cout << time_in_seconds << "s in strokeWidthTransform" << endl;
  start_time = clock();
  Mat ccmap(image_.size(), CV_32FC1, Scalar(-1));
  componentsRoi_.clear();
  nComponent_ = connectComponentAnalysis(swtmap, ccmap);
  time_in_seconds = (clock() - start_time) / (double)CLOCKS_PER_SEC;
  cout << time_in_seconds << "s in connectComponentAnalysis" << endl;
  start_time = clock();
  identifyLetters(swtmap, ccmap);
  time_in_seconds = (clock() - start_time) / (double)CLOCKS_PER_SEC;
  cout << time_in_seconds << "s in identifyLetters" << endl;
  start_time = clock();
  groupLetters(swtmap, ccmap);
  time_in_seconds = (clock() - start_time) / (double)CLOCKS_PER_SEC;
  cout << time_in_seconds << "s in groupLetters" << endl;
  start_time = clock();
  chainPairs(ccmap);
  time_in_seconds = (clock() - start_time) / (double)CLOCKS_PER_SEC;
  cout << time_in_seconds << "s in chainPairs" << endl;
  start_time = clock();
  time_in_seconds = (clock() - start_time) / (double)CLOCKS_PER_SEC;
  cout << time_in_seconds << "s in findRotationsangles" << endl;
  disposal();
  cout << "finish clean up" << endl;
    Canny(image_, edgemap_, 50, 120);
    Mat dx, dy;
    Sobel(image_, dx, CV_32FC1, 1, 0, 3);
    Sobel(image_, dy, CV_32FC1, 0, 1, 3);
    theta_ = Mat(image_.size(), CV_32FC1);
      edgepoints_.clear();
    for (int y = 0;
    for (int y = 0; y < edgemap_.rows;
      for (int x = 0;
      for (int x = 0; x < edgemap_.cols;
          theta_.at<float> (y, x) = atan2(dy.at<float> (y, x), dx.at<float> (y, x));
          edgepoints_.push_back(Point(x, y));
  vector<Point> strokePoints;
  updateStrokeWidth(swtmap, edgepoints_, strokePoints, searchDirection, UPDATE);
  updateStrokeWidth(swtmap, strokePoints, strokePoints, searchDirection, REFINE);
  vector<Point>::iterator itr = startPoints.begin();
  vector<Point> pointStack;
  vector<float> SwtValues;
  for (;
  for (; itr != startPoints.end();
    pointStack.clear();
    SwtValues.clear();
    float step = 1;
    float iy = (*itr).y;
    float ix = (*itr).x;
    float currY = iy;
    float currX = ix;
    bool isStroke = false;
    float iTheta = theta_.at<float> (*itr);
    pointStack.push_back(Point(currX, currY));
    SwtValues.push_back(swtmap.at<float> (currY, currX));
      float nextY = round(iy + sin(iTheta) * searchDirection * step);
      float nextX = round(ix + cos(iTheta) * searchDirection * step);
        break;
      step = step + 1;
        continue;
      currY = nextY;
      currX = nextX;
      pointStack.push_back(Point(currX, currY));
      SwtValues.push_back(swtmap.at<float> (currY, currX));
        float jTheta = theta_.at<float> (currY, currX);
          isStroke = true;
            strokePoints.push_back(Point(ix, iy));
        break;
      float newSwtVal;
        newSwtVal = sqrt((currY - iy) * (currY - iy) + (currX - ix) * (currX - ix));
        nth_element(SwtValues.begin(), SwtValues.begin() + SwtValues.size() / 2, SwtValues.end());
        newSwtVal = SwtValues[SwtValues.size() / 2];
      for (size_t i = 0;
      for (size_t i = 0; i < pointStack.size();
        swtmap.at<float> (pointStack[i]) = min(swtmap.at<float> (pointStack[i]), newSwtVal);
  for (int y = 0;
  for (int y = 0; y < swtmap.rows;
    for (int x = 0;
    for (int x = 0; x < swtmap.cols;
        swtmap.at<float> (y, x) = 0;
  int ccmapInitialVal = ccmap.at<float> (0, 0);
  int offsetY[] = {-1, -1, -1, 0, 0, 1, 1, 1};
  int offsetX[] = {-1, 0, 1, -1, 1, -1, 0, 1};
  int nNeighbors = 8;
  int label = 0;
  int vectorSize = ccmap.rows * ccmap.cols;
  int *pStack = new int[vectorSize * 2];
  int stackPointer;
  int *pVector = new int[vectorSize * 2];
  int vectorPointer;
  int currentPointX;
  int currentPointY;
  for (int y = 0;
  for (int y = 0; y < ccmap.rows;
    for (int x = 0;
    for (int x = 0; x < ccmap.cols;
      bool connected = false;
        vectorPointer = 0;
        stackPointer = 0;
        pStack[stackPointer] = x;
        pStack[stackPointer + 1] = y;
          currentPointX = pStack[stackPointer];
          currentPointY = pStack[stackPointer + 1];
          stackPointer -= 2;
          pVector[vectorPointer] = currentPointX;
          pVector[vectorPointer + 1] = currentPointY;
          vectorPointer += 2;
          for (int i = 0;
          for (int i = 0; i < nNeighbors;
            int ny = currentPointY + offsetY[i];
            int nx = currentPointX + offsetX[i];
              continue;
              ccmap.at<float> (ny, nx) = -2;
              continue;
              float sw1 = swtmap.at<float> (ny, nx);
              float sw2 = swtmap.at<float> (y, x);
                ccmap.at<float> (ny, nx) = label;
                stackPointer += 2;
                pStack[stackPointer] = nx;
                pStack[stackPointer + 1] = ny;
                connected = true;
          int minY = ccmap.rows, minX = ccmap.cols, maxY = 0, maxX = 0;
          int width, height;
          for (int i = 0;
          for (int i = 0; i < vectorPointer;
            minY = min(minY, pVector[i + 1]);
            minX = min(minX, pVector[i]);
            maxY = max(maxY, pVector[i + 1]);
            maxX = max(maxX, pVector[i]);
          width = maxX - minX + 1;
          height = maxY - minY + 1;
          Rect letterRoi(minX, minY, width, height);
          componentsRoi_.push_back(letterRoi);
          label++;
          ccmap.at<float> (y, x) = -2;
  delete[] pStack;
  delete[] pVector;
  return label;
  int showCcmap = 0;
  Mat output = originalImage_.clone();
  assert(static_cast<size_t>(nComponent_) == componentsRoi_.size());
  isLetterComponects_ = new bool[nComponent_];
  vector<float> iComponentStrokeWidth;
  cout << nComponent_ << "componets" << endl;
  bool *innerComponents = new bool[nComponent_];
  for (size_t i = 0;
  for (size_t i = 0; i < nComponent_;
    float maxStrokeWidth = 0;
    float sumStrokeWidth = 0;
    float currentStrokeWidth;
    bool isLetter = true;
    Rect *itr = &componentsRoi_[i];
      isLetterComponects_[i] = false;
      continue;
    float maxY = itr->y + itr->height;
    float minY = itr->y;
    float maxX = itr->x + itr->width;
    float minX = itr->x;
    float increment = abs(itr->width - itr->height) / 2;
    memset(innerComponents, 0, nComponent_ * sizeof(bool));
      maxY = min(maxY + increment, static_cast<float> (ccmap.rows));
      minY = max(minY - increment, static_cast<float> (0.0));
      maxX = min(maxX + increment, static_cast<float> (ccmap.cols));
      minX = max(minX - increment, static_cast<float> (0.0));
    for (int y = minY;
    for (int y = minY; y < maxY;
      for (int x = minX;
      for (int x = minX; x < maxX;
        int component = static_cast<int> (ccmap.at<float> (y, x));
          currentStrokeWidth = swtmap.at<float> (y, x);
          iComponentStrokeWidth.push_back(currentStrokeWidth);
          maxStrokeWidth = max(maxStrokeWidth, currentStrokeWidth);
          sumStrokeWidth += currentStrokeWidth;
          innerComponents[component] = true;
    float pixelCount = static_cast<float> (iComponentStrokeWidth.size());
    float mean = sumStrokeWidth / pixelCount;
    float variance = 0;
    for (size_t ii = 0;
    for (size_t ii = 0; ii < pixelCount;
      variance += (iComponentStrokeWidth[ii] - mean, 2) * (iComponentStrokeWidth[ii] - mean, 2);
    variance = variance / pixelCount;
    isLetter = isLetter && (variance / mean < 1.5);
    isLetter = isLetter && (sqrt(((itr->width) * (itr->width) + (itr->height) * (itr->height))) / maxStrokeWidth < 10);
    isLetter = isLetter && (pixelCount / maxStrokeWidth > 5);
    isLetter = isLetter && (itr->width < 2.5 * itr->height);
      isLetter = false;
    isLetterComponects_[i] = isLetter;
    iComponentStrokeWidth.clear();
    for (size_t i = 0;
    for (size_t i = 0; i < nComponent_;
            + componentsRoi_[i].width, componentsRoi_[i].y + componentsRoi_[i].height), cvScalar((150), (110), (50)), 1);
        cv::imshow("identify bright letters=ccmap[after]", output);
        cv::imshow("identify dark letters=ccmap[after]", output);
    waitKey(0);
  delete[] innerComponents;
  int showGroupedLetters = 0;
  componentsMeanIntensity_ = new float[nComponent_];
  componentsMedianStrokeWidth_ = new float[nComponent_];
  isGrouped_ = new bool[nComponent_];
  memset(componentsMeanIntensity_, 0, nComponent_ * sizeof(float));
  memset(componentsMedianStrokeWidth_, 0, nComponent_ * sizeof(float));
  memset(isGrouped_, false, nComponent_ * sizeof(bool));
  Mat output = originalImage_.clone();
  for (size_t i = 0;
  for (size_t i = 0; i < nComponent_;
      continue;
    Rect iRect = componentsRoi_[i];
    float iMeanIntensity = getMeanIntensity(ccmap, iRect, static_cast<int> (i));
    float iMedianStrokeWidth = getMedianStrokeWidth(ccmap, swtmap, iRect, static_cast<int> (i));
    for (size_t j = i + 1;
    for (size_t j = i + 1; j < nComponent_;
        continue;
      Rect jRect = componentsRoi_[j];
      bool horizontal = (iRect.y < jRect.y + jRect.height && jRect.y < iRect.y + iRect.height);
      bool vertical = (iRect.x < jRect.x + jRect.width && jRect.x < iRect.x + iRect.width);
        continue;
          horizontal = true;
          vertical = false;
          horizontal = false;
          vertical = true;
          + iRect.height / 2 - jRect.y - jRect.height / 2));
      int distanceRatio = 4;
          continue;
          continue;
      float jMeanIntensity = getMeanIntensity(ccmap, jRect, static_cast<int> (j));
      float jMedianStrokeWidth = getMedianStrokeWidth(ccmap, swtmap, jRect, static_cast<int> (j));
      bool isGroup = true;
          < 2;
      isGroup = isGroup && (max(iRect.height, jRect.height) / min(iRect.height, jRect.height)) < 2;
      isGroup = isGroup && abs(iMeanIntensity - jMeanIntensity) < 10;
        isGrouped_[i] = true;
        isGrouped_[j] = true;
          horizontalLetterGroups_.push_back(Pair(i, j));
                    cvScalar(0, 0, 255), 2);
                    cvScalar(0, 0, 255), 2);
      cv::imshow("bright", output);
      cv::imshow("dark", output);
    waitKey(0);
  int showpairs = 0;
  int showchains = 0;
    Mat output = originalImage_.clone();
    for (int i = 0;
    for (int i = 0; i < horizontalLetterGroups_.size() - 1;
                          + componentsRoi_.at(horizontalLetterGroups_[i].left).height), cvScalar(255, 255, 255), 2);
                          + componentsRoi_.at(horizontalLetterGroups_[i].right).height), cvScalar(255, 255, 255), 2);
    cv::imshow("pairs", output);
    waitKey(0);
  mergePairs(horizontalLetterGroups_, horizontalChains_);
  vector<Rect> initialHorizontalBoxes;
  chainToBox(horizontalChains_, initialHorizontalBoxes);
    Mat output = originalImage_.clone();
    for (int i = 0;
    for (int i = 0; i < initialHorizontalBoxes.size();
                    + initialHorizontalBoxes[i].height), cvScalar(155, 55, 255), 2);
    cv::imshow("chains", output);
    waitKey(0);
  filterBoundingBoxes(initialHorizontalBoxes, ccmap, 4);
  boundingBoxes_.insert(boundingBoxes_.end(), initialHorizontalBoxes.begin(), initialHorizontalBoxes.end());
    Mat output = originalImage_.clone();
    for (int i = 0;
    for (int i = 0; i < boundingBoxes_.size();
          + boundingBoxes_[i].width, boundingBoxes_[i].y + boundingBoxes_[i].height), cvScalar(0, 55, 105), 2);
    cv::imshow("chains2", output);
    waitKey(0);
  int showHistogram = 1;
  int showRects = 0;
  int padding = 10;
  bgr whiteClr;
  whiteClr.r = 255;
  whiteClr.g = 255;
  whiteClr.b = 255;
  cv::Mat canvas;
  canvas.create(125, 360, CV_8UC3);
  int maxValue = 0, maxAngle = 0, angles = 360;
  int hist[angles], newHistogram[angles];
  double scale;
  for (unsigned int i = 0;
  for (unsigned int i = 0; i < boundingBoxes_.size();
      cv::Mat output = originalImage_.clone();
                    2);
      cv::imshow("right rectangles", output);
      cv::waitKey(0);
    maxValue = 0;
    maxAngle = 0;
    for (int y = 0;
    for (int y = 0; y < canvas.rows;
      for (int x = 0;
      for (int x = 0; x < canvas.cols;
        canvas.at<bgr> (y, x) = whiteClr;
    for (int j = 0;
    for (int j = 0; j < angles - 1;
      hist[j] = 0;
    for (int y = boundingBoxes_[i].y;
    for (int y = boundingBoxes_[i].y; y < boundingBoxes_[i].y + boundingBoxes_[i].height;
      for (int x = boundingBoxes_[i].x;
      for (int x = boundingBoxes_[i].x; x < boundingBoxes_[i].x + boundingBoxes_[i].width;
          int angle = (int)((180 / 3.141592) * theta_.at<float> (y, x)) + 180;
          hist[angle]++;
    double mask[3];
    mask[0] = 0.25;
    mask[1] = 0.5;
    mask[2] = 0.25;
    for (int bin = 1;
    for (int bin = 1; bin < 359;
      double smoothedValue = 0;
      for (int i = 0;
      for (int i = 0; i < 3;
        smoothedValue += hist[bin - 1 + i] * mask[i];
      newHistogram[bin] = smoothedValue;
    newHistogram[0] = hist[0] * (2 / 3) + hist[1] * (1 / 3);
    newHistogram[359] = hist[358] * (1 / 3) + hist[359] * (2 / 3);
    for (int bin = 1;
    for (int bin = 1; bin < 360;
      hist[bin] = newHistogram[bin];
    for (int j = 0;
    for (int j = 0; j < angles - 1;
      maxValue = hist[j] > maxValue ? hist[j] : maxValue;
    for (int j = 0;
    for (int j = 0; j < angles - 1;
        maxAngle = j;
    scale = maxValue > canvas.rows ? (double)canvas.rows / maxValue : 1.;
      for (int j = 0;
      for (int j = 0; j < angles - 1;
        cv::Point pt1(j, canvas.rows - (hist[j] * scale));
        cv::Point pt2(j, canvas.rows);
          cv::line(canvas, pt1, pt2, cv::Scalar(200, 160, 100), 2, 8, 0);
          cv::line(canvas, pt1, pt2, cv::Scalar(250, 210, 150), 1, 8, 0);
                  false);
                  false);
                  false);
                  false);
                  false);
      cv::imshow("Gradients", canvas);
      std::cout << "blackWhite:" << blackWhite << endl;
      std::cout << "maxAngle:" << maxAngle << "(" << maxAngle - 180 << ")" << endl;
    cv::Rect rectWithPadding;
    rectWithPadding.x = max(boundingBoxes_[i].x - padding, 0);
    rectWithPadding.y = max(boundingBoxes_[i].y - padding, 0);
        : rectWithPadding.height = boundingBoxes_[i].height + padding;
        : rectWithPadding.width = boundingBoxes_[i].width + padding;
    cv::Mat smallImg = image_(rectWithPadding);
    cv::Scalar averageColor = mean(smallImg);
    std::vector<int> bgColor;
    for (int y = 0;
    for (int y = 0; y < smallImg.rows;
      for (int x = 0;
      for (int x = 0; x < smallImg.cols;
            bgColor.push_back((unsigned int)smallImg.at<unsigned char> (y, x));
            bgColor.push_back((unsigned int)smallImg.at<unsigned char> (y, x));
    int average_bg = 0;
    for (int i = 0;
    for (int i = 0; i < bgColor.size();
      average_bg += bgColor[i];
    average_bg = average_bg / bgColor.size();
    cv::Point2f center;
    center.x = smallImg.cols * 0.5;
    center.y = smallImg.rows * 0.5;
    cv::Mat mapMatrix = cv::getRotationMatrix2D(center, maxAngle - 180, 1.0);
    cv::Mat rotatedImage;
    rotatedImage.create(smallImg.rows, smallImg.cols, CV_8UC1);
    for (int y = 0;
    for (int y = 0; y < rotatedImage.rows;
      for (int x = 0;
      for (int x = 0; x < rotatedImage.cols;
        rotatedImage.at<unsigned char> (y, x) = average_bg;
                   cv::Scalar(average_bg));
    cv::imshow("rotated", rotatedImage);
                                                     boundingBoxes_[i].height));
    rotated.push_back(*r);
  for (size_t i = 0;
  for (size_t i = 0; i < chain.size();
      continue;
    int minX = image_.cols, minY = image_.rows, maxX = 0, maxY = 0;
    int letterAreaSum = 0;
    int padding = 5;
    for (size_t j = 0;
    for (size_t j = 0; j < chain[i].size();
      Rect *itr = &componentsRoi_[chain[i][j]];
      letterAreaSum += itr->width * itr->height;
      minX = min(minX, itr->x);
      minY = min(minY, itr->y);
      maxX = max(maxX, itr->x + itr->width);
      maxY = max(maxY, itr->y + itr->height);
    minX = max(0, minX - padding);
    minY = max(0, minY - padding);
    maxX = min(image_.cols, maxX + padding);
    maxY = min(image_.rows, maxY + padding);
    boundingBox.push_back(Rect(minX, minY, maxX - minX, maxY - minY));
  return a.y < b.y;
  vector<Rect> qualifiedBoxes;
  vector<int> components;
  for (size_t i = 0;
  for (size_t i = 0; i < boundingBoxes.size();
    int isLetterCount = 0;
    int letterArea = 0;
    int nonLetterArea = 0;
    Rect *rect = &boundingBoxes[i];
    float width = static_cast<float> (rect->width);
    float height = static_cast<float> (rect->height);
      continue;
      continue;
    for (int y = rect->y;
    for (int y = rect->y; y < rect->y + rect->height;
      for (int x = rect->x;
      for (int x = rect->x; x < rect->x + rect->width;
        int componetIndex = static_cast<int> (ccmap.at<float> (y, x));
          continue;
          letterArea++;
          nonLetterArea++;
          components.push_back(componetIndex);
            isLetterCount++;
      qualifiedBoxes.push_back(*rect);
    components.clear();
  boundingBoxes = qualifiedBoxes;
  vector<Rect> bigBoxes;
  Mat tempMap(image_.size(), CV_32FC1, Scalar(0));
  for (size_t i = 0;
  for (size_t i = 0; i < boundingBoxes.size();
    Rect *rect = &boundingBoxes[i];
    for (int y = rect->y;
    for (int y = rect->y; y < rect->y + rect->height;
      for (int x = rect->x;
      for (int x = rect->x; x < rect->x + rect->width;
        tempMap.at<float> (y, x) = 50;
  for (size_t i = 0;
  for (size_t i = 0; i < boundingBoxes.size();
      continue;
    Rect rect;
    floodFill(tempMap, Point(boundingBoxes[i].x, boundingBoxes[i].y), i + 100, &rect);
    int padding = 5;
    int minX = max(0, rect.x - padding);
    int minY = max(0, rect.y - padding);
    int maxX = min(image_.cols, rect.x + rect.width + padding);
    int maxY = min(image_.rows, rect.y + rect.height + padding);
    bigBoxes.push_back(Rect(minX, minY, maxX - minX, maxY - minY));
  boundingBoxes = bigBoxes;
  cout << endl;
  cout << "888" << endl;
  assert(box.size() == text.size());
  Scalar color(0, 255, 0);
  size_t lineWidth = 25;
  int indent = 50;
  int count = 1;
  for (size_t i = 0;
  for (size_t i = 0; i < box.size();
      indent = 70;
    string output = text[i];
      continue;
    std::string s;
    std::stringstream out;
    out << count;
    count++;
    string prefix = "[";
    prefix = prefix + out.str() + "]";
            color, 2);
    putText(detection_, prefix, Point(image_.cols, textDisplayOffset_ * 35), FONT_HERSHEY_DUPLEX, 1, color, 2);
              FONT_HERSHEY_DUPLEX, 1, color, 2);
      output = output.substr(lineWidth);
      textDisplayOffset_++;
    putText(detection_, output, Point(image_.cols + indent, textDisplayOffset_ * 35), FONT_HERSHEY_DUPLEX, 1, color, 2);
    textDisplayOffset_ += 2;
  sort(boundingBoxes.begin(), boundingBoxes.end(), DetectText::spaticalOrder);
  for (size_t i = 0;
  for (size_t i = 0; i < boundingBoxes.size();
    string result;
    float score = ocrRead(originalImage_(boundingBoxes[i]), result, -1);
      boxesBothSides_.push_back(boundingBoxes[i]);
      wordsBothSides_.push_back(result);
      boxesScores_.push_back(score);
  float score = 0;
  Mat scaledImage;
    double scale = 1.5;
    resize(imagePatch, scaledImage, Size(0, 0), scale, scale, INTER_LANCZOS4);
    imwrite("patch.tiff", scaledImage);
    imwrite("patch.tiff", imagePatch);
  system("$(cp patch.tiff ~)");
  int result;
  result = system("$(rospack find cob_tesseract)/bin/tesseract patch.tiff patch");
  cout << "result" << result << endl;
  assert(!result);
  ifstream fin("patch.txt");
  string str;
    cout << "in ocrRead:" << endl;
    cout << "[" << str << "]" << endl;
    string tempOutput;
    score += spellCheck(str, tempOutput, 2);
    output += tempOutput;
  result = system("$(rm patch.txt patch.tiff)");
  return score;
  int letterCount = 0, errorCount = 0, lNoiseCount = 0, digitCount = 0;
  string withoutStrangeMarks;
  float score = 0;
  str = trim(str);
  cout << "in spellCheck" << endl;
  for (size_t i = 0;
  for (size_t i = 0; i < str.length();
      withoutStrangeMarks += str[i];
      letterCount++;
        lNoiseCount++;
      digitCount++;
        withoutStrangeMarks += '1';
        str[i] = '1';
        digitCount++;
        withoutStrangeMarks += 'l';
        errorCount++;
        letterCount++;
      withoutStrangeMarks += 'L';
      errorCount++;
      letterCount++;
      withoutStrangeMarks += 'I';
      errorCount++;
      letterCount++;
      str[i] = ' ';
      output = str + " ";
      output = str + " ";
      const string command("echo " + withoutStrangeMarks + " | aspell -a >> output");
      int r = system(command.c_str());
      fstream fin("output");
      string result;
      int count = 0;
          count++;
            output += result + " ";
              ((output)[output.length() - 2] = ' ');
            break;
          count++;
          output += "{";
          output += " " + str;
          break;
        output += "}";
      r = system("rm output");
      cout << "METHOD==2" << endl;
      vector<Word> topk;
      string nearestWord;
      getTopkWords(withoutStrangeMarks, 3, topk);
        string topWord = topk[0].word;
        output = topk[0].word + " ";
            score++;
            output = "";
            score++;
            output = "";
            score = topWord.length() * 2;
            score = topWord.length();
          output = topk[0].word + " ";
          score += topk[0].word.length() * 2;
          output = "{" + withoutStrangeMarks + "->";
          for (int i = 0;
          for (int i = 0; i < 3;
            stringstream ss;
            ss << topk[i].score;
            string s = ss.str();
            output = output + topk[i].word + ":" + s + " ";
          output += "} ";
  return score;
  Mat result;
  Mat element = getStructuringElement(MORPH_ELLIPSE, Size(patch.cols / 3, patch.rows / 3));
  morphologyEx(patch, result, MORPH_TOPHAT, element);
  return result;
  delete[] isLetterComponects_;
  delete[] isGrouped_;
  delete[] componentsMeanIntensity_;
  delete[] componentsMedianStrokeWidth_;
  componentsRoi_.clear();
  innerComponents_.clear();
  horizontalLetterGroups_.clear();
  verticalLetterGroups_.clear();
  horizontalChains_.clear();
  verticalChains_.clear();
  std::cout << std::endl;
  std::cout << "Correlation:" << file << std::endl;
  ifstream fin(file);
  correlation_ = Mat(62, 62, CV_32F, Scalar(0));
  float number;
  for (int i = 0;
  for (int i = 0; i < 62;
    for (int j = 0;
    for (int j = 0; j < 62;
      assert(fin >> number);
      correlation_.at<float> (i, j) = number;
  ifstream fin(filename);
  string word;
  wordList_.clear();
    wordList_.push_back(word);
  assert(wordList_.size());
  cout << "read in " << wordList_.size() << " words from " << string(filename) << endl;
  size_t startpos = str.find_first_not_of(" \t");
  size_t endpos = str.find_last_not_of(" \t");
    str = "";
    str = str.substr(startpos, endpos - startpos + 1);
  return str;
  cout << "start searching match for " << str << endl;
  float score, lowestScore = 100;
  int referenceScore;
  size_t index = 0;
  for (size_t i = 0;
  for (size_t i = 0; i < wordList_.size();
    cout << "matching...." << wordList_[i];
    score = editDistanceFont(str, wordList_[i]);
    referenceScore = editDistance(str, wordList_[i]);
    cout << " " << score << " " << referenceScore << endl;
      lowestScore = score;
      cout << "AHA! better!" << endl;
      index = i;
  nearestWord = wordList_[index];
  cout << nearestWord << " got the lowest score: " << lowestScore << endl;
  float score, lowestScore = 100;
  words.clear();
  words.resize(k);
  cout << "in getTopkWords with [" << str << "]" << endl;
  for (size_t i = 0;
  for (size_t i = 0; i < wordList_.size();
    score = editDistanceFont(str, wordList_[i]);
      Word w = Word(wordList_[i], score);
      lowestScore = insertToList(words, w);
  cout << "lowestScore:" << lowestScore << endl;
  size_t index = 0;
  for (size_t i = 0;
  for (size_t i = 0; i < words.size();
    index = i;
      break;
    for (size_t i = words.size() - 1;
    for (size_t i = words.size() - 1; i > index;
      words[i] = words[i - 1];
    words[index] = word;
  return words[words.size() - 1].score;
    imwrite("edgemap.png", edgemap_);
  Mat ccmapLetters = ccmap * (1.0 / static_cast<float> (nComponent_));
  for (size_t i = 0;
  for (size_t i = 0; i < nComponent_;
    Rect *itr = &componentsRoi_[i];
    rectangle(ccmapLetters, Point(itr->x, itr->y), Point(itr->x + itr->width, itr->y + itr->height), Scalar(0.5));
    imwrite("ccmap1.jpg", ccmapLetters * nComponent_);
    imwrite("ccmap2.jpg", ccmapLetters * nComponent_);
    imwrite("swtmap1.jpg", swtmap * 10);
    imwrite("swtmap2.jpg", swtmap * 10);
  Mat output = originalImage_.clone();
  Scalar scalar;
    scalar = Scalar(0, 255, 0);
    scalar = Scalar(0, 0, 255);
  for (size_t i = 0;
  for (size_t i = 0; i < nComponent_;
      Rect *itr = &componentsRoi_[i];
      rectangle(output, Point(itr->x, itr->y), Point(itr->x + itr->width, itr->y + itr->height), scalar, 2);
      stringstream ss;
      string s;
      ss << i;
      s = ss.str() + ".tiff";
      imwrite(s, originalImage_(*itr));
    imwrite(outputPrefix_ + "_letters1.jpg", output);
    imwrite(outputPrefix_ + "_letters2.jpg", output);
  Mat output = originalImage_.clone();
  Scalar scalar;
    scalar = Scalar(0, 255, 0);
    scalar = Scalar(0, 0, 255);
  for (size_t i = 0;
  for (size_t i = 0; i < nComponent_;
      Rect *itr = &componentsRoi_[i];
      rectangle(output, Point(itr->x, itr->y), Point(itr->x + itr->width, itr->y + itr->height), scalar, 2);
    imwrite(outputPrefix_ + "_group1.jpg", output);
    imwrite(outputPrefix_ + "_group2.jpg", output);
  Scalar scalar(0, 0, 255);
  for (size_t i = 0;
  for (size_t i = 0; i < boundingBoxes.size();
    Rect *rect = &boundingBoxes[i];
    rectangle(detection_, Point(rect->x, rect->y), Point(rect->x + rect->width, rect->y + rect->height), scalar, 3);
  assert(boundingBoxes.size() == boxInbox.size());
  Scalar scalar;
  scalar = Scalar(0, 0, 255);
  for (size_t i = 0;
  for (size_t i = 0; i < boundingBoxes.size();
      continue;
    Rect *rect = &boundingBoxes[i];
    rectangle(detection_, Point(rect->x, rect->y), Point(rect->x + rect->width, rect->y + rect->height), scalar, 3);
  int count = 0;
  for (size_t i = 0;
  for (size_t i = 0; i < nComponent_;
      count++;
  return count;
  assert(element >= 0);
    float sum = 0;
    float count = 0;
    float felement = static_cast<float> (element);
    for (int y = rect.y;
    for (int y = rect.y; y < rect.y + rect.height;
      for (int x = rect.x;
      for (int x = rect.x; x < rect.x + rect.width;
          sum += static_cast<float> (image_.at<unsigned char> (y, x));
          count = count + 1;
    componentsMeanIntensity_[element] = sum / count;
  return componentsMeanIntensity_[element];
  assert(element >= 0);
  assert(isLetterComponects_[element]);
    vector<float> SwtValues;
    float felement = static_cast<float> (element);
    for (int y = rect.y;
    for (int y = rect.y; y < rect.y + rect.height;
      for (int x = rect.x;
      for (int x = rect.x; x < rect.x + rect.width;
          SwtValues.push_back(swtmap.at<float> (y, x));
    nth_element(SwtValues.begin(), SwtValues.begin() + SwtValues.size() / 2, SwtValues.end());
    componentsMedianStrokeWidth_[element] = SwtValues[SwtValues.size() / 2];
  return componentsMedianStrokeWidth_[element];
  vector<vector<int> > initialChains;
  initialChains.resize(groups.size());
  for (size_t i = 0;
  for (size_t i = 0; i < groups.size();
    vector<int> temp;
    temp.push_back(groups[i].left);
    temp.push_back(groups[i].right);
    initialChains[i] = temp;
    initialChains = chains;
    chains.clear();
    chains.clear();
  bool merged = false;
  int *mergedToChainBitMap = new int[initialChains.size()];
  memset(mergedToChainBitMap, -1, initialChains.size() * sizeof(int));
  for (size_t i = 0;
  for (size_t i = 0; i < initialChains.size();
      continue;
    for (size_t j = i + 1;
    for (size_t j = i + 1; j < initialChains.size();
      for (size_t ki = 0;
      for (size_t ki = 0; ki < initialChains[i].size();
        for (size_t kj = 0;
        for (size_t kj = 0; kj < initialChains[j].size();
            merged = true;
              merge(initialChains[i], chains[mergedToChainBitMap[j]]);
              mergedToChainBitMap[i] = mergedToChainBitMap[j];
              vector<int> newChain;
              merge(initialChains[i], newChain);
              merge(initialChains[j], newChain);
              chains.push_back(newChain);
              mergedToChainBitMap[i] = chains.size() - 1;
              mergedToChainBitMap[j] = chains.size() - 1;
            break;
          break;
      chains.push_back(initialChains[i]);
      mergedToChainBitMap[i] = chains.size() - 1;
    chains = initialChains;
  delete[] mergedToChainBitMap;
  return merged;
  vector<int>::iterator it;
  for (size_t i = 0;
  for (size_t i = 0; i < token.size();
    it = find(chain.begin(), chain.end(), token[i]);
      chain.push_back(token[i]);
  float penalty = 0.7;
  int n = s.length();
  int m = t.length();
    return m;
    return n;
  float **d = new float*[n + 1];
  for (int i = 0;
  for (int i = 0; i < n + 1;
    d[i] = new float[m + 1];
    memset(d[i], 0, (m + 1) * sizeof(float));
  for (int i = 0;
  for (int i = 0; i < n + 1;
    d[i][0] = i;
  for (int j = 0;
  for (int j = 0; j < m + 1;
    d[0][j] = j;
  for (int i = 1;
  for (int i = 1; i < n + 1;
    char sc = s[i - 1];
    for (int j = 1;
    for (int j = 1; j < m + 1;
      float v = d[i - 1][j - 1];
        int a = getCorrelationIndex(t[j - 1]);
        int b = getCorrelationIndex(sc);
          cout << "Wort:" << t << endl;
        float correlate = correlation_.at<float> (a, b);
        v = v + 1 - correlate;
      d[i][j] = min(min(d[i - 1][j] + penalty, d[i][j - 1] + penalty), v);
  float result = d[n][m];
  for (int i = 0;
  for (int i = 0; i < n + 1;
    delete[] d[i];
  delete[] d;
  return result;
    return letter - 'a';
    return letter - 'A' + 26;
    return letter - '0' + 52;
  cout << "illigal letter: " << letter << endl;
  return -1;
  int n = s.length();
  int m = t.length();
    return m;
    return n;
  int **d = new int*[n + 1];
  for (int i = 0;
  for (int i = 0; i < n + 1;
    d[i] = new int[m + 1];
    memset(d[i], 0, (m + 1) * sizeof(int));
  for (int i = 0;
  for (int i = 0; i < n + 1;
    d[i][0] = i;
  for (int j = 0;
  for (int j = 0; j < m + 1;
    d[0][j] = j;
  for (int i = 1;
  for (int i = 1; i < n + 1;
    char sc = s[i - 1];
    for (int j = 1;
    for (int j = 1; j < m + 1;
      int v = d[i - 1][j - 1];
        v++;
      d[i][j] = min(min(d[i - 1][j] + 1, d[i][j - 1] + 1), v);
  return d[n][m];
  assert(getCorrelationIndex('a') == 0);
  assert(getCorrelationIndex('c') == 2);
  assert(getCorrelationIndex('A') == 26);
  assert(getCorrelationIndex('0') == 52);
  assert(getCorrelationIndex('9') == 61);
  cout << "pass getCorrelationIndex test" << endl;
  string a("hello");
  string b("helo");
  assert(editDistance(a,b)==1);
  string c("hello");
  string d("xello");
  cout << "distance betweeen " << c << " & " << d << ": " << editDistance(c, d) << endl;
  cout << "distance with font betweeen " << c << " & " << d << ":" << editDistanceFont(c, d) << endl;
  vector<Word> list;
  list.resize(10);
  for (int i = 0;
  for (int i = 0; i < 10;
    float score = rand() % 50;
    Word w = Word("", score);
    insertToList(list, w);
    for (size_t i = 0;
    for (size_t i = 0; i < 10;
      cout << list[i].score << " <= ";
    cout << endl;
  int a[] = {1, 2, 3};
  int b[] = {2, 3, 9};
  int c[] = {7, 5};
  int d[] = {2, 4, 6};
  vector<vector<int> > initialChain;
  vector<vector<int> > outputChain;
  vector<int> va(a, a + 3);
  vector<int> vb(b, b + 3);
  vector<int> vc(c, c + 2);
  vector<int> vd(d, d + 3);
  initialChain.push_back(va);
  initialChain.push_back(vb);
  initialChain.push_back(vc);
  initialChain.push_back(vd);
    initialChain = outputChain;
    outputChain.clear();
  for (size_t i = 0;
  for (size_t i = 0; i < outputChain.size();
    for (size_t j = 0;
    for (size_t j = 0; j < outputChain[i].size();
      cout << outputChain[i][j] << " ";
    cout << endl;
  Mat temp(edgemap_.size(), CV_8UC1);
  vector<Point>::iterator itr = edgepoints.begin();
  for (;
  for (; itr != edgepoints.end();
    temp.at<unsigned char> (*itr) = 255;
  imshow("test edge", temp);
  waitKey();
namespace enc = sensor_msgs::image_encodings;
static const char WINDOW[] = "Image window";
<font color="#FF0000">  ros::NodeHandle nh_;</font>{}
  image_transport::ImageTransport it_;
  image_transport::Subscriber image_sub_;
  image_transport::Publisher image_pub_;
<font color="#FF0000">  ros::Subscriber robot_state_sub_;</font>{}
<font color="#FF0000">  ros::Subscriber depth_sub_;</font>{}
  DetectText detector;
  ros::Time last_movement_;
  pthread_mutex_t pr2_velocity_lock_;
  pthread_mutex_t pr2_image_lock_;
  cv_bridge::CvImagePtr cv_ptr;
  cv_bridge::CvImagePtr detection_ptr;
  float x_;
  float y_;
  bool okToDetect_;
  bool initialized_;
    image_pub_ = it_.advertise("text_detect", 1);
<font color="#FF0000">    image_sub_ = it_.subscribe("image_color", 1, &TextReader::imageCb, this);</font>{}
<font color="#FF0000">    robot_state_sub_ = nh_.subscribe("/base_odometry/state", 1, &TextReader::robotStateCb, this);</font>{}
    detector = DetectText();
    detector.readLetterCorrelation(correlation);
    detector.readWordList(dictionary);
    pthread_mutex_init(&pr2_velocity_lock_, NULL);
    pthread_mutex_init(&pr2_image_lock_, NULL);
    okToDetect_ = false;
    initialized_ = false;
    x_ = 0;
    y_ = 0;
    pthread_mutex_trylock(&pr2_velocity_lock_);
    x_ = msg->velocity.linear.x;
    y_ = msg->velocity.linear.y;
      last_movement_ = ros::Time::now();
    pthread_mutex_unlock(&pr2_velocity_lock_);
      pthread_mutex_trylock(&pr2_image_lock_);
      cv_ptr = cv_bridge::toCvCopy(msg, enc::BGR8);
        detection_ptr = cv_bridge::toCvCopy(msg, enc::BGR8);
        initialized_ = true;
      okToDetect_ = true;
      pthread_mutex_unlock(&pr2_image_lock_);
      ROS_ERROR("cv_bridge exception: %s", e.what());
      okToDetect_ = false;
      return;
};
    ROS_ERROR( "not enought input: read_text <correlation> <dictionary>");
    return 1;
<font color="#FF0000">  ros::init(argc, argv, "cob_read_text");</font>{}
  TextReader reader(argv[1], argv[2]);
  DetectText &detector = reader.detector;
  ros::Rate r(1);
  ros::Time last_detection = ros::Time::now();
      ROS_INFO("start detection........");
      ros::Time now = ros::Time::now();
        ROS_INFO("waiting...");
        ros::spinOnce();
        r.sleep();
        continue;
      pthread_mutex_lock(&(reader.pr2_velocity_lock_));
      bool is_steady = (now - reader.last_movement_ > ros::Duration(2));
      bool is_moving = (reader.x_ != 0 || reader.y_ != 0);
      pthread_mutex_unlock(&(reader.pr2_velocity_lock_));
        ros::spinOnce();
        r.sleep();
        continue;
      pthread_mutex_lock(&(reader.pr2_image_lock_));
      detector.detect(reader.cv_ptr->image);
      pthread_mutex_unlock(&(reader.pr2_image_lock_));
      reader.detection_ptr->image = detector.getDetection();
<font color="#FF0000">      reader.image_pub_.publish(reader.detection_ptr->toImageMsg());</font>{}
    std::cout << "----------------------------------" << endl;
    std::cout << "Texts found: " << detector.getWords().size() << endl;
    for (int i = 0;
    for (int i = 0; i < detector.getWords().size();
          << ",width=" << ((detector.getBoxesBothSides())[0]).width << endl;
    std::cout << "----------------------------------" << endl;
    last_detection = ros::Time::now();
    ros::spinOnce();
    r.sleep();
  return 0;
</pre>
</body>
</html>
